[
  {
    "objectID": "slides/slide-ja.html#overview",
    "href": "slides/slide-ja.html#overview",
    "title": "Introduction to Coding Agents",
    "section": "Overview",
    "text": "Overview\n\n自己紹介\nAI を用いたソフトウェアの紹介\nAI エージェントの導入\nいくつかの題材をもとに演習"
  },
  {
    "objectID": "slides/slide-ja.html#自己紹介",
    "href": "slides/slide-ja.html#自己紹介",
    "title": "Introduction to Coding Agents",
    "section": "自己紹介",
    "text": "自己紹介\n\nフリーランスソフトウェアエンジニア． 大学教員と科学計算の共同開発\nGitHub: terasakisatoshi\nOrganization: AtelierArith"
  },
  {
    "objectID": "slides/slide-ja.html#最近行ってること-organizing-sparseir-ecosystem",
    "href": "slides/slide-ja.html#最近行ってること-organizing-sparseir-ecosystem",
    "title": "Introduction to Coding Agents",
    "section": "最近行ってること: Organizing SparseIR ecosystem",
    "text": "最近行ってること: Organizing SparseIR ecosystem\n\nHiroshi Shinaoka, Hitoshi Mori との共同開発\n\nPorting SparseIR.jl v1.0 to C++: libsparseir (C++)\nPorting libsparseir to Rust: sparse-ir-rs\nSparseIR.jl v2.0 (Julia interface for sparse-ir-rs)\nsparse-ir v2.0 (Python interface for sparse-ir-rs)"
  },
  {
    "objectID": "slides/slide-ja.html#最近行ってること-tensor4all",
    "href": "slides/slide-ja.html#最近行ってること-tensor4all",
    "title": "Introduction to Coding Agents",
    "section": "最近行ってること: tensor4all",
    "text": "最近行ってること: tensor4all\n\ntensor4all: A Rust implementation of tensor networks\n\nPorting Strided.jl to Rust strided-rs\nstrided-rs-benchmark-suite"
  },
  {
    "objectID": "slides/slide-ja.html#最近行ってること-mvmc",
    "href": "slides/slide-ja.html#最近行ってること-mvmc",
    "title": "Introduction to Coding Agents",
    "section": "最近行ってること: mVMC",
    "text": "最近行ってること: mVMC\n\nTakahiro Misawa et al.\n\nPorting C project mVMC to Julia (WIP)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis project is still work in progress. It will be released in the future."
  },
  {
    "objectID": "slides/slide-ja.html#最近行ってること-subsetjuliavm",
    "href": "slides/slide-ja.html#最近行ってること-subsetjuliavm",
    "title": "Introduction to Coding Agents",
    "section": "最近行ってること: SubsetJuliaVM",
    "text": "最近行ってること: SubsetJuliaVM\nLet’s run Julia on iPad and iPhone"
  },
  {
    "objectID": "slides/slide-ja.html#最近行ってること-better-pluto-client",
    "href": "slides/slide-ja.html#最近行ってること-better-pluto-client",
    "title": "Introduction to Coding Agents",
    "section": "最近行ってること: better-pluto-client",
    "text": "最近行ってること: better-pluto-client\nWe can view pluto notebook on VS Code."
  },
  {
    "objectID": "slides/slide-ja.html#最近行ってること-rustcall.jl",
    "href": "slides/slide-ja.html#最近行ってること-rustcall.jl",
    "title": "Introduction to Coding Agents",
    "section": "最近行ってること: RustCall.jl",
    "text": "最近行ってること: RustCall.jl\nJulia から Rust を呼び出すことができるパッケージ．\nusing RustCall\n\nrust\"\"\"\n#[julia]\nfn add(a: i32, b: i32) -&gt; i32 {\n    a + b\n}\n\"\"\"\n\n# Call directly - wrapper is auto-generated\nadd(10, 20)  # =&gt; 30"
  },
  {
    "objectID": "slides/slide-ja.html#actually",
    "href": "slides/slide-ja.html#actually",
    "title": "Introduction to Coding Agents",
    "section": "Actually",
    "text": "Actually\n今まで紹介したソフトウェアは 9 割以上は AI を用いてコードを生成している．これは事実です．\n人間は自然言語で作りたいものを指示し AI Agent はソースコードを生成・コマンドの実行を行う．\nAI を用いて開発を効率よく進める手法を AI-driven 開発と呼ぶ"
  },
  {
    "objectID": "slides/slide-ja.html#現実では",
    "href": "slides/slide-ja.html#現実では",
    "title": "Introduction to Coding Agents",
    "section": "現実では",
    "text": "現実では\n\n\nGit が使われていない．バージョン管理されてない\nドキュメントがない，または古い\n単体テストがない\nコンパイルができない\n実行時エラーが起きる(セグメンテーションフォルトなど)\nデータセットの URL が 研究者個人の C ドライブ(変数のハードコーディング)"
  },
  {
    "objectID": "slides/slide-ja.html#人間と機械",
    "href": "slides/slide-ja.html#人間と機械",
    "title": "Introduction to Coding Agents",
    "section": "人間と機械",
    "text": "人間と機械\n\n人間は「創造」することができるが「疲れる」,「飽きる」,「固執する」\n\n研究活動のような新しいアイデアを出す\ngit commit -m \"update\" git commit -m \"fix\" を使いまくる\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n特定のプログラミング言語を使い続ける\n\nパッケージマネージャを使うなど現代的な開発手法を取り入れることが困難な環境を生む"
  },
  {
    "objectID": "slides/slide-ja.html#人間と機械-1",
    "href": "slides/slide-ja.html#人間と機械-1",
    "title": "Introduction to Coding Agents",
    "section": "人間と機械",
    "text": "人間と機械\n\n人間は「創造」することができるが「疲れる」,「飽きる」,「固執する」\n\n\n親愛なる科学者の皆様，これから新しい数値計算ソフトウェアを書く場合は科学技術計算には Julia または Rust を使いましょう． これらは現代的なパッケージマネージメントシステムを備えており，共同で開発することを可能にします．\n\n\nJulia は高級言語でありながら高速な実行をユーザに提供します． あなたが普段 Fortran を書くのであれば使うべきでしょう． ただし, 型不安定なコード, GC (ガベージコレクション) が頻発するケース, メモリアロケーションが発生するケースでは十分なパフォーマンスが発揮できません． 多次元配列を扱うテンソルネットワークのパッケージはこの問題によく出会います．\n\n\nRust は高速に動作する静的言語です． C/C++ を書く人はこの言語に乗り換えることを検討するべきでしょう． Rust は人間が手動で書くのは学習コストがかかりますが，AI によるコード生成により開発体験が劇的に改善します．\n\n\nテンソルネットワークに関するエコシステム tensor4all-rs は科学技術計算のために Rust を採用した非常に良い例を目指しています．"
  },
  {
    "objectID": "slides/slide-ja.html#人間と機械-2",
    "href": "slides/slide-ja.html#人間と機械-2",
    "title": "Introduction to Coding Agents",
    "section": "人間と機械",
    "text": "人間と機械\n\n機械は「飽きない」,「疲れない」,「モデルが成長」\n\nコードの差分から適切なコミット・プリクエストの概要を作成"
  },
  {
    "objectID": "slides/slide-ja.html#人間と機械-3",
    "href": "slides/slide-ja.html#人間と機械-3",
    "title": "Introduction to Coding Agents",
    "section": "人間と機械",
    "text": "人間と機械\n\n機械は「飽きない」,「疲れない」,「モデルが成長」\nいつでも動作をする\n\n様々な言語を使える．移植も得意:\nJulia -&gt; C++, C++ -&gt; Rust, C -&gt; Julia\nTypeScript, Swift, Flutter/Dart\n\n要請に応じて変更が可能．現代的な言語にマイグレーションが可能\n人間からの適切な指示が必要"
  },
  {
    "objectID": "slides/slide-ja.html#コーディングエージェントの登場",
    "href": "slides/slide-ja.html#コーディングエージェントの登場",
    "title": "Introduction to Coding Agents",
    "section": "コーディングエージェントの登場",
    "text": "コーディングエージェントの登場\n人工知能・生成 AI の発展により コーディングエージェント・AI エージェントは人間が指示を与えたら目標を達成するために下記の行動をすることが可能になった:"
  },
  {
    "objectID": "slides/slide-ja.html#人間は不要かno",
    "href": "slides/slide-ja.html#人間は不要かno",
    "title": "Introduction to Coding Agents",
    "section": "人間は不要か？(No)",
    "text": "人間は不要か？(No)\n\nLLM は多くの知識を持っているが，研究者のように最先端の知識を持っているとは限らない．何を実装するか，しないかは人間の能力に左右される．\nソフトウェアエンジニアはコーディングする時間から解放されるが，どのような技術をどの場面で使うか，高品質なソフトウェアを作成・維持するためのアーキテクチャを考える・意思決定をする上位の能力が求められるようになる．コーディング以外に研究者と議論するための最低限のドメイン知識も求められるようになる．"
  },
  {
    "objectID": "slides/slide-ja.html#人間は不要かno-1",
    "href": "slides/slide-ja.html#人間は不要かno-1",
    "title": "Introduction to Coding Agents",
    "section": "人間は不要か？(No)",
    "text": "人間は不要か？(No)\n\nAI がコードを書いてもサボるケースがある\n\nプレースホルダーだけ書いて満足する\n汎用な実装が求められるケースで特殊なケースだけを想定したケースでのみ実装してしまう．\n\nベストプラクティスな実装とは限らない．\n\nJulia だと多重ディスパッチを使わない，export を多用する\nRust だと .clone() の多用をする．パフォーマンスの劣化\n\n最低限のコードの実行方法，コーディングの知識，プログラミング言語の知識は必要．"
  },
  {
    "objectID": "slides/slide-ja.html#ソフトウェアエンジニアは不要か",
    "href": "slides/slide-ja.html#ソフトウェアエンジニアは不要か",
    "title": "Introduction to Coding Agents",
    "section": "ソフトウェアエンジニアは不要か？",
    "text": "ソフトウェアエンジニアは不要か？\n\nAI が発達することで研究者は不要になるというぐらい過激な主張\nAI の導入によって言語の学習コスト・細かい文法・コーディングスタイルのような局所的な議論から解放される．\n「ユーザにとって体験が良いソフトウェアをどのように設計するか」，「状況・目的に応じてどのような技術，プログラミング言語を選択すべきか」「高品質なソフトウェアをどのように維持するべきか」といったアーキテクチャレベルの設計・大域的な議論に集中することができる． 何を実装するか実装すべきでないかは人間の判断に大きく判断される．\nVisual profiler を用いたボトルネックの調査は AI による完全自動化は難しい．そのようはワークフローはまだ存在する．\n\nミリ秒, マイクロ秒, ナノ秒レベルの最適化をする仕事は人間の直感が大事．需要はまだあると思う"
  },
  {
    "objectID": "slides/slide-ja.html#ソフトウェアエンジニアは不要か-1",
    "href": "slides/slide-ja.html#ソフトウェアエンジニアは不要か-1",
    "title": "Introduction to Coding Agents",
    "section": "ソフトウェアエンジニアは不要か？",
    "text": "ソフトウェアエンジニアは不要か？\n\nドメイン知識を身についけることが大事，物理学者とコミュニケーションする程度の物理学の知識\nRust で書かれたコードは Web Assembly の技術で Web で実行することができる．数値計算のデモを Web で公開・メンテナンスをする仕事は出てくる．"
  },
  {
    "objectID": "slides/slide-ja.html#ソフトウェアエンジニアは不要か-2",
    "href": "slides/slide-ja.html#ソフトウェアエンジニアは不要か-2",
    "title": "Introduction to Coding Agents",
    "section": "ソフトウェアエンジニアは不要か？",
    "text": "ソフトウェアエンジニアは不要か？\n\n研究者は忙しくなる．今までできなかったけれど，やりたかったことができるようになる．それに応じて仕事も増えてくるはず．\n研究者は暇にならない．ある研究者は Claude Code MAX $200 を契約し，AI をフル活用したせいで目眩を引き起こした．\n\n私は $100 プランまでダウングレードすることを推奨した．ジョークのようで本当の話"
  },
  {
    "objectID": "slides/slide-ja.html#ソフトウェアエンジニアは不要か-3",
    "href": "slides/slide-ja.html#ソフトウェアエンジニアは不要か-3",
    "title": "Introduction to Coding Agents",
    "section": "ソフトウェアエンジニアは不要か？",
    "text": "ソフトウェアエンジニアは不要か？\n\n仕事がなくなるときはある種の情熱がなくなるときだと思う．"
  },
  {
    "objectID": "slides/slide-ja.html#デモを行います",
    "href": "slides/slide-ja.html#デモを行います",
    "title": "Introduction to Coding Agents",
    "section": "デモを行います",
    "text": "デモを行います\nCursor を用いたコーディングの方法を紹介する．\n代替として Antigravity, Claude Code, Codex を使うこともできる．"
  },
  {
    "objectID": "slides/slide-ja.html#どのツールを使うべきか",
    "href": "slides/slide-ja.html#どのツールを使うべきか",
    "title": "Introduction to Coding Agents",
    "section": "どのツールを使うべきか",
    "text": "どのツールを使うべきか\n\nAI Agent は常に進化しているので答えはない．\nどのアカウントを持っているかによる．\n\nChatGPT を契約していれば Codex, GPT-5.3 を使ってみる\nClaude を契約していれば Claude Code: Opus-4.6 を使ってみる\n\n無料で使いたい\n\nGoogle が出している Antigravity を使う\n\nどのサービスも使用上限が存在する．すべてはお金次第．"
  },
  {
    "objectID": "slides/slide-ja.html#どのツールを使うべきかas-for-me",
    "href": "slides/slide-ja.html#どのツールを使うべきかas-for-me",
    "title": "Introduction to Coding Agents",
    "section": "どのツールを使うべきか(as for me)",
    "text": "どのツールを使うべきか(as for me)\n\nClaude Code MAX $200/$100: Opus-4.6\nChatGPT Plus plan: Codex: GPT-5.3\nCursor Pro: 日常のエディタとして Composer 1.5"
  },
  {
    "objectID": "slides/slide-ja.html#必要な-cli-ツール",
    "href": "slides/slide-ja.html#必要な-cli-ツール",
    "title": "Introduction to Coding Agents",
    "section": "必要な CLI ツール",
    "text": "必要な CLI ツール\n\ngit, gh: Git/GitHub を操作する\nuv: Python package manager\nnpm, node: コーディングエージェントのインストール\njuliaup, julia: Julia のコードを実行するために必要\nrustup, rustc, cargo: Rust のコードをビルド・実行に必要\n\nOptional:\n\ndocker\ndevcontainer\nrg\ntree\nhtop\nquarto"
  },
  {
    "objectID": "slides/slide-ja.html#インストール",
    "href": "slides/slide-ja.html#インストール",
    "title": "Introduction to Coding Agents",
    "section": "インストール",
    "text": "インストール\nTODO 01-preparation.qmd に記述する"
  },
  {
    "objectID": "slides/slide-ja.html#インストール-1",
    "href": "slides/slide-ja.html#インストール-1",
    "title": "Introduction to Coding Agents",
    "section": "インストール",
    "text": "インストール\n下記リンクに移動し\n\nhttps://cursor.com/download\nVS Code ユーザは extension をマイグレートできる．"
  },
  {
    "objectID": "slides/slide-ja.html#math-quiz",
    "href": "slides/slide-ja.html#math-quiz",
    "title": "Introduction to Coding Agents",
    "section": "Math Quiz",
    "text": "Math Quiz\n二つのの正の整数 \\(a\\), \\(b\\) が与えられた時，最大公約数 \\(\\gcd(a,b)\\) が 1 になる確率はどれくらい？\n\n正解は\n\\[\n\\frac{1}{\\zeta(2)} = \\frac{6}{\\pi^2} \\approx 0.6079271018540267\n\\]\nここで，\\(\\zeta\\) はリーマン・ゼータ関数である．\n\\[\n\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s}= \\prod_{p: \\mathrm{primes} } \\left(\\frac{1}{1 - p^{-s}}  \\right) \\mathrm{}\n\\]\nここで，2番目の等式は Euler product によるものである．"
  },
  {
    "objectID": "slides/slide-ja.html#証明",
    "href": "slides/slide-ja.html#証明",
    "title": "Introduction to Coding Agents",
    "section": "証明",
    "text": "証明\n\\[\n\\begin{aligned}\n\\mathrm{Prob}(\\gcd(a, b) = 1)\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - \\mathrm{Prob}(p | a \\textrm{ and } p | b)\\right) \\\\\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - \\mathrm{Prob}(p | a)\\mathrm{Prob}(p | b)\\right) \\\\\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - \\frac{1}{p}\\cdot\\frac{1}{p}\\right) \\\\\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - p^{-2}\\right) \\\\\n&= \\left(\\prod_{p: \\mathrm{primes} } \\left(\\frac{1}{1 - p^{-2}}  \\right)\\right)^{-1} \\\\\n&=\\left(\\zeta(2)\\right)^{-1} \\\\\n&= \\frac{1}{\\zeta(2)} = \\frac{6}{\\pi^2}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "slides/slide-ja.html#application-js-implementation",
    "href": "slides/slide-ja.html#application-js-implementation",
    "title": "Introduction to Coding Agents",
    "section": "Application (JS implementation)",
    "text": "Application (JS implementation)\n先ほどの証明から次を得る:\n\\[\n\\pi = \\sqrt{\\frac{6}{\\mathrm{Prob}(\\gcd(a, b)=1)}}\n\\]\n数値計算で確かめてみよう\n// Function to approximate pi\n// using probability that two numbers are coprime\nfunction calcPi(N) {\n    let cnt = 0;    // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for (let a = 1; a &lt;= N; a++) {\n        for (let b = 1; b &lt;= N; b++) {\n            // Check if a and b are coprime\n            if (mygcd(a, b) === 1) {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt / (N * N);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return Math.sqrt(6 / prob);\n}"
  },
  {
    "objectID": "slides/slide-ja.html#application-js-implementation-1",
    "href": "slides/slide-ja.html#application-js-implementation-1",
    "title": "Introduction to Coding Agents",
    "section": "Application (JS implementation)",
    "text": "Application (JS implementation)\nLet’s calculate the \\(\\pi \\approx 3.14...\\) from GCD function:\n// approx_pi_gcd.js\n\n// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nfunction mygcd(a, b) {\n    // Loop until the remainder is zero\n    while (b !== 0) {\n        let tmp = b;    // Store the value of b temporarily\n        b = a % b;      // Update b to the remainder of a divided by b\n        a = tmp;        // Set a to the previous value of b\n    }\n    return a;           // When b is zero, a is the GCD\n}\n\n// Function to approximate pi using probability that two numbers are coprime\nfunction calcPi(N) {\n    let cnt = 0;    // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for (let a = 1; a &lt;= N; a++) {\n        for (let b = 1; b &lt;= N; b++) {\n            // Check if a and b are coprime\n            if (mygcd(a, b) === 1) {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt / (N * N);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return Math.sqrt(6 / prob);\n}\n\n// Main function to run the pi approximation\nfunction main() {\n    let N = 10000;            // Number limit for coprimality checking\n    let pi = calcPi(N);       // Approximate pi\n    console.log(`N: ${N}`);   // Output N\n    console.log(`pi: ${pi}`); // Output approximation of pi\n}\n\nmain(); // Call the main function\nResult\n$ node approx_pi_gcd.js\ncalcPi: 2.175s\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide-ja.html#exercise",
    "href": "slides/slide-ja.html#exercise",
    "title": "Introduction to Coding Agents",
    "section": "Exercise",
    "text": "Exercise\n先ほどの JavaScript のコードを Julia, Rust に移植してください． N=10000 の時の実行時間を計測してください．\nHint\n下記のプロンプトを使う\n\nPort approx_pi_gcd.js to Julia and save the result as approx_pi_gcd.jl\n\n\nPort approx_pi_gcd.rs to Rust and save the result as approx_pi_gcd.rs"
  },
  {
    "objectID": "slides/slide-ja.html#answer",
    "href": "slides/slide-ja.html#answer",
    "title": "Introduction to Coding Agents",
    "section": "Answer",
    "text": "Answer"
  },
  {
    "objectID": "slides/slide-ja.html#answerjulia",
    "href": "slides/slide-ja.html#answerjulia",
    "title": "Introduction to Coding Agents",
    "section": "Answer(Julia)",
    "text": "Answer(Julia)\n# Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nfunction mygcd(a, b)\n    # Loop until the remainder is zero\n    while b != 0\n        tmp = b    # Store the value of b temporarily\n        b = a % b  # Update b to the remainder of a divided by b\n        a = tmp    # Set a to the previous value of b\n    end\n    return a       # When b is zero, a is the GCD\nend\n\n# Function to approximate pi using probability that two numbers are coprime\nfunction calcPi(N)\n    cnt = 0    # Counter for coprime pairs\n    # Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1:N\n        for b in 1:N\n            # Check if a and b are coprime\n            if mygcd(a, b) == 1\n                cnt += 1  # Increment counter if coprime\n            end\n        end\n    end\n    # Probability that two numbers are coprime\n    prob = cnt / (N * N)\n    # Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return sqrt(6 / prob)\nend\n\n# Main function to run the pi approximation\nfunction main()\n    N = 10000            # Number limit for coprimality checking\n    approx_pi = @time calcPi(N) # Approximate pi and time it\n    println(\"N: $(N)\")   # Output N\n    println(\"pi: $(approx_pi)\") # Output approximation of pi\nend\n\nmain() # Call the main function\nResult\n$ julia approx_pi_gcd.jl\n  1.865392 seconds\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide-ja.html#answer-rust",
    "href": "slides/slide-ja.html#answer-rust",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Rust)",
    "text": "Answer (Rust)\n// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nfn mygcd(a: u64, b: u64) -&gt; u64 {\n    let mut a = a;\n    let mut b = b;\n    // Loop until the remainder is zero\n    while b != 0 {\n        let tmp = b;    // Store the value of b temporarily\n        b = a % b;      // Update b to the remainder of a divided by b\n        a = tmp;        // Set a to the previous value of b\n    }\n    a                   // When b is zero, a is the GCD\n}\n\n// Function to approximate pi using probability that two numbers are coprime\nfn calc_pi(n: u64) -&gt; f64 {\n    let mut cnt = 0u64; // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1..=n {\n        for b in 1..=n {\n            // Check if a and b are coprime\n            if mygcd(a, b) == 1 {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt as f64 / (n as f64 * n as f64);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    (6.0 / prob).sqrt()\n}\n\n// Main function to run the pi approximation\nfn main() {\n    let n = 10000u64;   // Number limit for coprimality checking\n    let start = std::time::Instant::now();\n    let pi = calc_pi(n); // Approximate pi\n    let duration = start.elapsed();\n    println!(\"calcPi: {:?}\", duration);\n    println!(\"N: {}\", n);   // Output N\n    println!(\"pi: {}\", pi); // Output approximation of pi\n}\nResult\n$ rustc -C opt-level=3 approx_pi_gcd.rs && ./approx_pi_gcd\ncalcPi: 1.754083333s\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide-ja.html#answer-c",
    "href": "slides/slide-ja.html#answer-c",
    "title": "Introduction to Coding Agents",
    "section": "Answer (C)",
    "text": "Answer (C)\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;time.h&gt;\n\n// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nint mygcd(int a, int b) {\n    // Loop until the remainder is zero\n    while (b != 0) {\n        int tmp = b;    // Store the value of b temporarily\n        b = a % b;      // Update b to the remainder of a divided by b\n        a = tmp;        // Set a to the previous value of b\n    }\n    return a;           // When b is zero, a is the GCD\n}\n\n// Function to approximate pi using probability that two numbers are coprime\ndouble calcPi(int N) {\n    int cnt = 0;    // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for (int a = 1; a &lt;= N; a++) {\n        for (int b = 1; b &lt;= N; b++) {\n            // Check if a and b are coprime\n            if (mygcd(a, b) == 1) {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    double prob = (double)cnt / (N * N);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return sqrt(6.0 / prob);\n}\n\n// Main function to run the pi approximation\nint main() {\n    int N = 10000;            // Number limit for coprimality checking\n    clock_t start = clock();\n    double pi = calcPi(N);    // Approximate pi\n    clock_t end = clock();\n    double cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\n\n    printf(\"calcPi: %f seconds\\n\", cpu_time_used);\n    printf(\"N: %d\\n\", N);     // Output N\n    printf(\"pi: %f\\n\", pi);   // Output approximation of pi\n\n    return 0;\n}\nResult\n$ gcc -O3 approx_pi_gcd.c && ./a.out\ncalcPi: 1.753796 seconds\nN: 10000\npi: 3.141534"
  },
  {
    "objectID": "slides/slide-ja.html#julia-can-execute-this-much-faster.",
    "href": "slides/slide-ja.html#julia-can-execute-this-much-faster.",
    "title": "Introduction to Coding Agents",
    "section": "Julia can execute this much faster.",
    "text": "Julia can execute this much faster.\n# Function to approximate pi using probability that two numbers are coprime\nfunction calcPi(N)\n    cnt = 0    # Counter for coprime pairs\n    # Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1:N\n        for b in 1:N\n            # Check if a and b are coprime\n            if gcd(a, b) == 1\n                cnt += 1  # Increment counter if coprime\n            end\n        end\n    end\n    # Probability that two numbers are coprime\n    prob = cnt / (N * N)\n    # Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return sqrt(6 / prob)\nend\n\n# Main function to run the pi approximation\nfunction main()\n    N = 10000            # Number limit for coprimality checking\n    approx_pi = @time calcPi(N) # Approximate pi and time it\n    println(\"N: $(N)\")   # Output N\n    println(\"pi: $(approx_pi)\") # Output approximation of pi\nend\n\nmain() # Call the main function\nResult\njulia approx_pi_gcd.jl\n  1.454210 seconds\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide-ja.html#julia-が速くなった",
    "href": "slides/slide-ja.html#julia-が速くなった",
    "title": "Introduction to Coding Agents",
    "section": "Julia が速くなった?!",
    "text": "Julia が速くなった?!\n1.865392 seconds -&gt; 1.454210 seconds となる理由は？\nJulia が提供する gcd 関数はユークリッド互除法とは異なるアルゴリズムを用いているからである．"
  },
  {
    "objectID": "slides/slide-ja.html#exercise-1",
    "href": "slides/slide-ja.html#exercise-1",
    "title": "Introduction to Coding Agents",
    "section": "Exercise",
    "text": "Exercise\n\nJulia のリポジトリをクローンしてコーディングエージェントに gcd 関数がどのようになっているかを答えさせよ．\n採用しているアルゴリズムは何かを答えさせよ．\n先ほど JavaScript から Rust に移植したコードで mygcd の代わりに Julia が実装している gcd 関数を移植させよ．\n\nHint\n\ngit clone --depth 1 &lt;url&gt; ですばやくクローンができる(shallow clone). Use the following prompt:\n\n\nRead the Julia code and answer how the gcd function is defined. Read @julia\n\n\nPort these gcd functions to Rust"
  },
  {
    "objectID": "slides/slide-ja.html#answer-1",
    "href": "slides/slide-ja.html#answer-1",
    "title": "Introduction to Coding Agents",
    "section": "Answer",
    "text": "Answer\n\n\n\n\nIndeed, the code is as follows:\n# binary GCD (aka Stein's) algorithm\n# about 1.7x (2.1x) faster for random Int64s (Int128s)\n# Unfortunately, we need to manually annotate this as `@assume_effects :terminates_locally` to work around #41694.\n# Since this is used in the Rational constructor, constant folding is something we do care about here.\n@assume_effects :terminates_locally function _gcd(ain::T, bin::T) where T&lt;:BitInteger\n    zb = trailing_zeros(bin)\n    za = trailing_zeros(ain)\n    a = abs(ain)\n    b = abs(bin &gt;&gt; zb)\n    k = min(za, zb)\n    while a != 0\n        a &gt;&gt;= za\n        absd, diff = absdiff(a, b)\n        za = trailing_zeros(diff)\n        b = min(a, b)\n        a = absd\n    end\n    r = b &lt;&lt; k\n    return r % T\nend"
  },
  {
    "objectID": "slides/slide-ja.html#answer-cursor-with-auto-mode",
    "href": "slides/slide-ja.html#answer-cursor-with-auto-mode",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Cursor with Auto-mode)",
    "text": "Answer (Cursor with Auto-mode)"
  },
  {
    "objectID": "slides/slide-ja.html#answer-rust-implementation",
    "href": "slides/slide-ja.html#answer-rust-implementation",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Rust implementation)",
    "text": "Answer (Rust implementation)\n// Port of Julia's gcd functions from base/intfuncs.jl\n// Greatest common divisor implementations using Euclidean and Binary GCD algorithms\n\nuse std::ops::{Rem, Shr, Shl, Sub, BitAnd};\n\n/// Greatest common (positive) divisor (or zero if all arguments are zero).\n///\n/// This is the general implementation for all integer types using the Euclidean algorithm.\npub fn gcd&lt;T&gt;(mut a: T, mut b: T) -&gt; T\nwhere\n    T: Copy + PartialEq + Rem&lt;Output = T&gt; + From&lt;u8&gt; + Default,\n{\n    let zero = T::from(0u8);\n    while b != zero {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    checked_abs(a)\n}\n\n/// Greatest common divisor for fixed-width integer types using Binary GCD (Stein's) algorithm.\n///\n/// This is about 1.7x (2.1x) faster for random Int64s (Int128s) compared to Euclidean algorithm.\npub fn gcd_bitinteger&lt;T&gt;(a: T, b: T) -&gt; T\nwhere\n    T: Copy\n        + PartialEq\n        + PartialOrd\n        + Shr&lt;usize, Output = T&gt;\n        + Shl&lt;usize, Output = T&gt;\n        + BitAnd&lt;Output = T&gt;\n        + Sub&lt;Output = T&gt;\n        + From&lt;u8&gt;\n        + Default,\n{\n    let zero = T::from(0u8);\n\n    if a == zero {\n        return checked_abs(b);\n    }\n    if b == zero {\n        return checked_abs(a);\n    }\n\n    // Handle typemin case for signed types\n    // In Rust, we check for the minimum value differently\n    // For now, we'll proceed with the algorithm\n\n    _gcd(a, b)\n}\n\n/// Binary GCD (aka Stein's) algorithm implementation.\n///\n/// This is the core algorithm that's faster for fixed-width integers.\nfn _gcd&lt;T&gt;(ain: T, bin: T) -&gt; T\nwhere\n    T: Copy\n        + PartialEq\n        + PartialOrd\n        + Shr&lt;usize, Output = T&gt;\n        + Shl&lt;usize, Output = T&gt;\n        + BitAnd&lt;Output = T&gt;\n        + Sub&lt;Output = T&gt;\n        + From&lt;u8&gt;\n        + Default,\n{\n    let zero = T::from(0u8);\n\n    let zb = trailing_zeros(bin);\n    let mut za = trailing_zeros(ain);\n    let mut a = abs(ain);\n    let mut b = abs(bin &gt;&gt; zb);\n    let k = if za &lt; zb { za } else { zb };\n\n    while a != zero {\n        a = a &gt;&gt; za;\n        let (absd, diff) = absdiff(a, b);\n        za = trailing_zeros(diff);\n        b = if a &lt; b { a } else { b };\n        a = absd;\n    }\n\n    let r = b &lt;&lt; k;\n    r\n}\n\n/// Compute absolute difference between two values.\n/// Returns (absolute difference, signed difference).\nfn absdiff&lt;T&gt;(x: T, y: T) -&gt; (T, T)\nwhere\n    T: Copy + PartialOrd + Sub&lt;Output = T&gt; + From&lt;u8&gt;,\n{\n    if x &gt;= y {\n        let d = x - y;\n        (d, d)\n    } else {\n        let d = y - x;\n        (d, d)\n    }\n}\n\n/// Compute the number of trailing zeros in the binary representation.\n///\n/// For unsigned types, this counts trailing zeros.\n/// For signed types, we convert to unsigned first.\nfn trailing_zeros&lt;T&gt;(x: T) -&gt; usize\nwhere\n    T: Copy,\n{\n    // This is a simplified version. In practice, you'd use the built-in\n    // trailing_zeros method for each integer type.\n    // For a generic implementation, we'd need trait bounds that include\n    // the actual integer traits.\n\n    // For now, we'll use a basic implementation\n    // In real code, you'd specialize for each integer type\n    if let Some(val) = try_to_u64(x) {\n        val.trailing_zeros() as usize\n    } else {\n        // Fallback: count manually\n        count_trailing_zeros_fallback(x)\n    }\n}\n\n/// Try to convert a value to u64 for trailing_zeros calculation.\nfn try_to_u64&lt;T&gt;(_x: T) -&gt; Option&lt;u64&gt; {\n    None // Generic implementation - would need specialization\n}\n\n/// Fallback trailing zeros counting.\nfn count_trailing_zeros_fallback&lt;T&gt;(_x: T) -&gt; usize {\n    0 // Placeholder - would need proper implementation\n}\n\n/// Compute absolute value with overflow checking.\nfn checked_abs&lt;T&gt;(x: T) -&gt; T\nwhere\n    T: Copy,\n{\n    // For unsigned types, abs is a no-op\n    // For signed types, we'd use checked_abs\n    // This is a simplified version\n    abs(x)\n}\n\n/// Compute absolute value.\nfn abs&lt;T&gt;(x: T) -&gt; T\nwhere\n    T: Copy,\n{\n    // For unsigned types, this is a no-op\n    // For signed types, we'd need to handle negation\n    // This is a simplified generic version\n    x\n}\n\n// Specialized implementations for specific integer types\n\n/// GCD for u8\npub fn gcd_u8(a: u8, b: u8) -&gt; u8 {\n    gcd_bitinteger_u8(a, b)\n}\n\n/// Binary GCD for u8 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u8(ain: u8, bin: u8) -&gt; u8 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u16\npub fn gcd_u16(a: u16, b: u16) -&gt; u16 {\n    gcd_bitinteger_u16(a, b)\n}\n\n/// Binary GCD for u16 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u16(ain: u16, bin: u16) -&gt; u16 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u32\npub fn gcd_u32(a: u32, b: u32) -&gt; u32 {\n    gcd_bitinteger_u32(a, b)\n}\n\n/// Binary GCD for u32 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u32(ain: u32, bin: u32) -&gt; u32 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u64\npub fn gcd_u64(a: u64, b: u64) -&gt; u64 {\n    gcd_bitinteger_u64(a, b)\n}\n\n/// Binary GCD for u64 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u64(ain: u64, bin: u64) -&gt; u64 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u128\npub fn gcd_u128(a: u128, b: u128) -&gt; u128 {\n    gcd_bitinteger_u128(a, b)\n}\n\n/// Binary GCD for u128 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u128(ain: u128, bin: u128) -&gt; u128 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for i8\npub fn gcd_i8(a: i8, b: i8) -&gt; i8 {\n    gcd_bitinteger_i8(a, b)\n}\n\n/// Binary GCD for i8 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i8(ain: i8, bin: i8) -&gt; i8 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    // Handle typemin case\n    if ain == i8::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i8\n}\n\n/// GCD for i16\npub fn gcd_i16(a: i16, b: i16) -&gt; i16 {\n    gcd_bitinteger_i16(a, b)\n}\n\n/// Binary GCD for i16 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i16(ain: i16, bin: i16) -&gt; i16 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i16::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i16\n}\n\n/// GCD for i32\npub fn gcd_i32(a: i32, b: i32) -&gt; i32 {\n    gcd_bitinteger_i32(a, b)\n}\n\n/// Binary GCD for i32 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i32(ain: i32, bin: i32) -&gt; i32 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i32::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i32\n}\n\n/// GCD for i64\npub fn gcd_i64(a: i64, b: i64) -&gt; i64 {\n    gcd_bitinteger_i64(a, b)\n}\n\n/// Binary GCD for i64 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i64(ain: i64, bin: i64) -&gt; i64 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i64::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i64\n}\n\n/// GCD for i128\npub fn gcd_i128(a: i128, b: i128) -&gt; i128 {\n    gcd_bitinteger_i128(a, b)\n}\n\n/// Binary GCD for i128 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i128(ain: i128, bin: i128) -&gt; i128 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i128::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i128\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gcd_u64() {\n        assert_eq!(gcd_u64(6, 9), 3);\n        assert_eq!(gcd_u64(6, 0), 6);\n        assert_eq!(gcd_u64(0, 0), 0);\n        assert_eq!(gcd_u64(48, 18), 6);\n        assert_eq!(gcd_u64(17, 13), 1);\n    }\n\n    #[test]\n    fn test_gcd_i64() {\n        assert_eq!(gcd_i64(6, 9), 3);\n        assert_eq!(gcd_i64(6, -9), 3);\n        assert_eq!(gcd_i64(-6, 9), 3);\n        assert_eq!(gcd_i64(-6, -9), 3);\n        assert_eq!(gcd_i64(6, 0), 6);\n        assert_eq!(gcd_i64(0, 0), 0);\n    }\n\n    #[test]\n    fn test_gcd_u32() {\n        assert_eq!(gcd_u32(48, 18), 6);\n        assert_eq!(gcd_u32(100, 25), 25);\n    }\n\n    #[test]\n    fn test_gcd_i32() {\n        assert_eq!(gcd_i32(48, -18), 6);\n        assert_eq!(gcd_i32(-100, 25), 25);\n    }\n}\n\n// Function to approximate pi using probability that two numbers are coprime\nfn calc_pi(n: u64) -&gt; f64 {\n    let mut cnt = 0u64; // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1..=n {\n        for b in 1..=n {\n            // Check if a and b are coprime using the fast binary GCD algorithm\n            if gcd::gcd_u64(a, b) == 1 {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt as f64 / (n as f64 * n as f64);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    (6.0 / prob).sqrt()\n}\n\n// Main function to run the pi approximation\nfn main() {\n    let n = 10000u64;   // Number limit for coprimality checking\n    let start = std::time::Instant::now();\n    let pi = calc_pi(n); // Approximate pi\n    let duration = start.elapsed();\n    println!(\"calcPi: {:?}\", duration);\n    println!(\"N: {}\", n);   // Output N\n    println!(\"pi: {}\", pi); // Output approximation of pi\n}\nResult\nrustc -C opt-level=3 gcd.rs && ./gcd\ncalcPi: 1.2510425s\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide-ja.html#binary-gcd-algorithm-はさらに速くすることができる",
    "href": "slides/slide-ja.html#binary-gcd-algorithm-はさらに速くすることができる",
    "title": "Introduction to Coding Agents",
    "section": "Binary GCD Algorithm はさらに速くすることができる",
    "text": "Binary GCD Algorithm はさらに速くすることができる\nExercise\n\nBinary GCD Algorithm をさらに高速化せよ (1.45 -&gt; 1.07 seconds on Julia)\n\nHint\n\nBinary GCD Algorithm を Rust で実装し，実行時間を計測せよ\nRust の実装は Julia より速い場合，Rust の実行ファイルを読み込んで Julia の @code_native マクロが出力する機械語と比べよ\n命令数が少ないと実行速度が向上するので比較結果を Julia のコードにフィードバックせよ"
  },
  {
    "objectID": "slides/slide-ja.html#answer-2",
    "href": "slides/slide-ja.html#answer-2",
    "title": "Introduction to Coding Agents",
    "section": "Answer",
    "text": "Answer\n\nOpus 4.5 generated this!\n\nRust\nBenchmark:\nRun 1: 1.05132725s  pi=3.141534239016629\nRun 2: 1.0358485s  pi=3.141534239016629\nRun 3: 1.034275125s  pi=3.141534239016629\nJulia\n$ julia src/main.jl\nRunning tests...\nAll tests passed!\n\nBenchmark:\nRun 1: 1.072994208s  pi=3.141534239016629\nRun 2: 1.07328325s  pi=3.141534239016629\nRun 3: 1.072947583s  pi=3.141534239016629"
  },
  {
    "objectID": "slides/slide-ja.html#another-example",
    "href": "slides/slide-ja.html#another-example",
    "title": "Introduction to Coding Agents",
    "section": "Another example",
    "text": "Another example\nWhat is the expected number of random numbers (generated uniformly) such that their sum of numbers exceeds one?\nRefer this discussion on MathOverflow.\n練習問題\n数値計算のプログラムを書いてみよう．色々なプログラミング言語でトライしてみよう"
  },
  {
    "objectID": "slides/slide-ja.html#answer-julia",
    "href": "slides/slide-ja.html#answer-julia",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Julia)",
    "text": "Answer (Julia)\nfunction count_upto_one()\n    counter = 0\n    accumulated = 0.0\n    while true\n        accumulated += rand()\n        counter += 1\n        if accumulated &gt;= 1.0\n            break\n        end\n    end\n    return counter\nend\n\nfunction main()\n    n_trial =1e8\n    total_count=0\n    for trial in 1:n_trial\n        total_count+=count_upto_one()\n    end\n    println(total_count/n_trial)\nend\n\nmain()"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "CompPhysHack2026HandsOn by AtelierArith",
    "section": "",
    "text": "This website provides lecture materials for participants of CompPhysHack 2026.\n\n\nWith advances in artificial intelligence and large language models, coding agents have emerged. These agents autonomously generate source code and execute commands based on human instructions, providing support for coding and software development. This lecture introduces coding agents such as Claude Code and Cursor, and teaches how to leverage them through several hands-on exercises.\n\n\n\n\nPreparation\nSlide\n\n\n\n\nThis website is built with Quarto. It may be used freely for educational and research purposes.\nLast modified: 2026-02-24"
  },
  {
    "objectID": "index.html#introduction",
    "href": "index.html#introduction",
    "title": "CompPhysHack2026HandsOn by AtelierArith",
    "section": "",
    "text": "With advances in artificial intelligence and large language models, coding agents have emerged. These agents autonomously generate source code and execute commands based on human instructions, providing support for coding and software development. This lecture introduces coding agents such as Claude Code and Cursor, and teaches how to leverage them through several hands-on exercises."
  },
  {
    "objectID": "index.html#handouts",
    "href": "index.html#handouts",
    "title": "CompPhysHack2026HandsOn by AtelierArith",
    "section": "",
    "text": "Preparation\nSlide"
  },
  {
    "objectID": "index.html#other",
    "href": "index.html#other",
    "title": "CompPhysHack2026HandsOn by AtelierArith",
    "section": "",
    "text": "This website is built with Quarto. It may be used freely for educational and research purposes.\nLast modified: 2026-02-24"
  },
  {
    "objectID": "handouts/preparation/preparation.html",
    "href": "handouts/preparation/preparation.html",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "This document was created for CompPhysHack 2026.\nHumans give instructions in natural language for what they want to build, and AI agents generate source code and execute commands. This approach to development using AI is called AI-driven development. Similar terms include Vibe coding, Agentic engineering, and Agentic coding.\nGetting started is very easy. Install an AI agent from your preferred platform and try the prompts below.\nFor Julia users:\nI want to create a Julia package for simulating and visualizing elastic collisions of multiple balls in 2D space.\nFor Rust users:\nI want to create a Rust crate for simulating and visualizing elastic collisions of multiple balls in 2D space.\nWe used English prompts here, but you can give instructions in any natural language such as Japanese. You can expect output similar to this example. The source code was generated using the Composer 1.5 model from Cursor.\n\n\n\n\nThere is no single answer since AI agents are constantly evolving. A good starting point depends on which accounts you have. You can also ask colleagues or friends nearby.\n\nIf you have a ChatGPT subscription, try Codex or GPT-5.3-Codex\nIf you have a Claude subscription, try Claude Code: Opus-4.6\n\nIf you want to use something for free:\n\nGitHub Copilot\n\nGemini CLI\nGoogle Antigravity\n\n\nAll services have usage limits. It all comes down to budget. Participants of CompPhysHack 2026 will likely need some paid plan to fully enjoy the event.\n\nThe author of this document uses the following setup:\n\nClaude Code MAX $200/$100: Opus-4.6\n\nDelegates coding to AI\n\nChatGPT Plus plan $20: Codex: GPT-5.3\n\nWants a different perspective from Claude Code\n\nCursor Pro plan $20: Daily editor with Composer 1.5\n\nExcels at code completion. Seamlessly passing integrated terminal error output to the AI agent provides a good user experience\n\n\n\n\n\nParticipants of CompPhysHack 2026 are assumed to have some software development experience. Here we install various AI agents via CLI tools.\n\n\nnpm is the package manager for Node.js. Node.js is a JavaScript runtime. This step is required to install Codex CLI and Gemini CLI.\n\nFollow the instructions at Download Node.js.\n\nThe following describes installation of various CLI tools; you do not need to install all of them.\n\n\n\n\nhttps://developers.openai.com/codex/cli/\n\n$ npm i -g @openai/codex\n$ codex\nA ChatGPT subscription is required to use it.\n\n\n\n$ npm install -g @google/gemini-cli\n$ gemini\nSee https://github.com/google-gemini/gemini-cli to learn more.\nA Google account is required to use it.\n\n\n\nmacOS, Linux, WSL:\n$ curl -fsSL https://claude.ai/install.sh | bash\n$ claude\nWindows PowerShell:\nPS&gt; irm https://claude.ai/install.ps1 | iex\n\n\n\n$ npm install -g @github/copilot\n$ copilot\nSee https://github.com/github/copilot-cli to learn more.\n\n\n\n\nInstall VS Code or its derivatives: Cursor or Google Antigravity. You do not need to install all of them.\n\n\nFollow the instructions at the links below:\n\nhttps://code.visualstudio.com/download\nhttps://github.com/features/copilot\n\n\n\n\nFollow the instructions at the link below:\nhttps://cursor.com/download\nYou can also use Cursor as a CLI tool with cursor-agent.\n\n\n\nFollow the instructions at the link below:\nhttps://antigravity.google/download\n\n\n\n\nHere we install CLI tools useful for modern general software development (including numerical computing).\n\n\nMany AI agents use the gh command to create GitHub issues and pull requests. This automates many tedious tasks.\nRead the instructions at https://cli.github.com/ to install.\nmacOS:\n% brew install gh\nLinux users should refer to Installing gh on Linux and BSD.\nWindows users should refer to Installing gh on Windows.\n\n\n\nJulia is a general-purpose programming language well-suited for scientific and technical computing.\nFollow the instructions at Installing Julia.\nmacOS or Linux:\n$ curl -fsSL https://install.julialang.org | sh\nWindows:\nPS&gt; winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n\n\n\nRust was developed for systems programming but is also gaining attention in scientific computing. Follow the instructions at Install Rust.\nmacOS or Linux:\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nSee this instructions if you are using Windows.\nThe commands above will make cargo, rustc, and similar commands available. Verify the installation as follows:\n$ cargo new hello-world\n$ cd hello-world\n$ cargo run --release\ncargo run --release\n   Compiling hello-world v0.1.0 (path/to/your-workspace/hello-world)\n    Finished `release` profile [optimized] target(s) in 1.38s\n     Running `target/release/hello-world`\nHello, world!\n\n\n\nPython excels as a scripting language, but the proliferation of package managers has caused much confusion in the community. uv may put an end to that—at least, we hope so. uv is a fast Python package manager implemented in Rust.\nFollow the instructions at Installing uv.\nmacOS or Linux:\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\nVerify the installation:\n$ mkdir path/to/your-workspace\n$ cd path/to/your-workspace\n$ uv init\n$ uv run python main.py\n\n\n\nClaude Code and Codex offer options to bypass user permission prompts, such as --allow-dangerously-skip-permissions and --yolo. While convenient, these options can also allow execution of dangerous commands like rm -rf /. To prevent such situations, it is advisable to use a sandboxed environment. For example, Docker containers can restrict the scope of AI agent actions by limiting which files are mounted.\nInstall according to your OS:\n\nInstall Docker Desktop on Windows\nInstall Docker Desktop on Mac\nInstall Docker Desktop on Linux\n\nVerify the installation with the following command:\n$ docker run --rm hello-world\n\n\n\nBuilding an environment with Docker requires creating a Dockerfile. Building from scratch is tedious. Devcontainer’s Development Container Features let you assemble self-contained configurations called “Features” as building blocks for your environment. This allows you to use Julia, Python, Rust, and more freely inside Docker containers.\nInstall as follows according to Dev Container CLI:\n$ npm install -g @devcontainers/cli\nYou can verify with the following commands:\n$ git clone https://github.com/microsoft/vscode-remote-try-rust\n$ cd vscode-remote-try-rust\n$ devcontainer build\n$ devcontainer up --workspace-folder ./\n$ devcontainer exec --workspace-folder ./ bash\nvscode ➜ /workspaces/vscode-remote-try-rust (main) $ cargo run\n   Compiling hello_remote_world v0.1.0 (/workspaces/vscode-remote-try-rust)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/hello_remote_world`\nHello, VS Code Remote - Containers!\n\n\n\n\nThe following are installation steps for commands used by the author of this document. You may skip this section.\n\n\nText-mode interface for git\n% brew install tig\n\n\n\nA richer alternative to the top command. Used for visually monitoring CPU usage.\n% brew install htop\n\n\n\nCodex users may find this useful.\n% brew install ripgrep\n\n\n\nRequired if you want to view this document locally.\nSee Welcome to Quarto to learn more."
  },
  {
    "objectID": "handouts/preparation/preparation.html#which-tool-should-you-use",
    "href": "handouts/preparation/preparation.html#which-tool-should-you-use",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "There is no single answer since AI agents are constantly evolving. A good starting point depends on which accounts you have. You can also ask colleagues or friends nearby.\n\nIf you have a ChatGPT subscription, try Codex or GPT-5.3-Codex\nIf you have a Claude subscription, try Claude Code: Opus-4.6\n\nIf you want to use something for free:\n\nGitHub Copilot\n\nGemini CLI\nGoogle Antigravity\n\n\nAll services have usage limits. It all comes down to budget. Participants of CompPhysHack 2026 will likely need some paid plan to fully enjoy the event.\n\nThe author of this document uses the following setup:\n\nClaude Code MAX $200/$100: Opus-4.6\n\nDelegates coding to AI\n\nChatGPT Plus plan $20: Codex: GPT-5.3\n\nWants a different perspective from Claude Code\n\nCursor Pro plan $20: Daily editor with Composer 1.5\n\nExcels at code completion. Seamlessly passing integrated terminal error output to the AI agent provides a good user experience"
  },
  {
    "objectID": "handouts/preparation/preparation.html#installing-command-line-interface-cli-tools",
    "href": "handouts/preparation/preparation.html#installing-command-line-interface-cli-tools",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "Participants of CompPhysHack 2026 are assumed to have some software development experience. Here we install various AI agents via CLI tools.\n\n\nnpm is the package manager for Node.js. Node.js is a JavaScript runtime. This step is required to install Codex CLI and Gemini CLI.\n\nFollow the instructions at Download Node.js.\n\nThe following describes installation of various CLI tools; you do not need to install all of them.\n\n\n\n\nhttps://developers.openai.com/codex/cli/\n\n$ npm i -g @openai/codex\n$ codex\nA ChatGPT subscription is required to use it.\n\n\n\n$ npm install -g @google/gemini-cli\n$ gemini\nSee https://github.com/google-gemini/gemini-cli to learn more.\nA Google account is required to use it.\n\n\n\nmacOS, Linux, WSL:\n$ curl -fsSL https://claude.ai/install.sh | bash\n$ claude\nWindows PowerShell:\nPS&gt; irm https://claude.ai/install.ps1 | iex\n\n\n\n$ npm install -g @github/copilot\n$ copilot\nSee https://github.com/github/copilot-cli to learn more."
  },
  {
    "objectID": "handouts/preparation/preparation.html#installing-ai-enabled-integrated-development-environments",
    "href": "handouts/preparation/preparation.html#installing-ai-enabled-integrated-development-environments",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "Install VS Code or its derivatives: Cursor or Google Antigravity. You do not need to install all of them.\n\n\nFollow the instructions at the links below:\n\nhttps://code.visualstudio.com/download\nhttps://github.com/features/copilot\n\n\n\n\nFollow the instructions at the link below:\nhttps://cursor.com/download\nYou can also use Cursor as a CLI tool with cursor-agent.\n\n\n\nFollow the instructions at the link below:\nhttps://antigravity.google/download"
  },
  {
    "objectID": "handouts/preparation/preparation.html#software-installation",
    "href": "handouts/preparation/preparation.html#software-installation",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "Here we install CLI tools useful for modern general software development (including numerical computing).\n\n\nMany AI agents use the gh command to create GitHub issues and pull requests. This automates many tedious tasks.\nRead the instructions at https://cli.github.com/ to install.\nmacOS:\n% brew install gh\nLinux users should refer to Installing gh on Linux and BSD.\nWindows users should refer to Installing gh on Windows.\n\n\n\nJulia is a general-purpose programming language well-suited for scientific and technical computing.\nFollow the instructions at Installing Julia.\nmacOS or Linux:\n$ curl -fsSL https://install.julialang.org | sh\nWindows:\nPS&gt; winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n\n\n\nRust was developed for systems programming but is also gaining attention in scientific computing. Follow the instructions at Install Rust.\nmacOS or Linux:\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nSee this instructions if you are using Windows.\nThe commands above will make cargo, rustc, and similar commands available. Verify the installation as follows:\n$ cargo new hello-world\n$ cd hello-world\n$ cargo run --release\ncargo run --release\n   Compiling hello-world v0.1.0 (path/to/your-workspace/hello-world)\n    Finished `release` profile [optimized] target(s) in 1.38s\n     Running `target/release/hello-world`\nHello, world!\n\n\n\nPython excels as a scripting language, but the proliferation of package managers has caused much confusion in the community. uv may put an end to that—at least, we hope so. uv is a fast Python package manager implemented in Rust.\nFollow the instructions at Installing uv.\nmacOS or Linux:\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\nVerify the installation:\n$ mkdir path/to/your-workspace\n$ cd path/to/your-workspace\n$ uv init\n$ uv run python main.py\n\n\n\nClaude Code and Codex offer options to bypass user permission prompts, such as --allow-dangerously-skip-permissions and --yolo. While convenient, these options can also allow execution of dangerous commands like rm -rf /. To prevent such situations, it is advisable to use a sandboxed environment. For example, Docker containers can restrict the scope of AI agent actions by limiting which files are mounted.\nInstall according to your OS:\n\nInstall Docker Desktop on Windows\nInstall Docker Desktop on Mac\nInstall Docker Desktop on Linux\n\nVerify the installation with the following command:\n$ docker run --rm hello-world\n\n\n\nBuilding an environment with Docker requires creating a Dockerfile. Building from scratch is tedious. Devcontainer’s Development Container Features let you assemble self-contained configurations called “Features” as building blocks for your environment. This allows you to use Julia, Python, Rust, and more freely inside Docker containers.\nInstall as follows according to Dev Container CLI:\n$ npm install -g @devcontainers/cli\nYou can verify with the following commands:\n$ git clone https://github.com/microsoft/vscode-remote-try-rust\n$ cd vscode-remote-try-rust\n$ devcontainer build\n$ devcontainer up --workspace-folder ./\n$ devcontainer exec --workspace-folder ./ bash\nvscode ➜ /workspaces/vscode-remote-try-rust (main) $ cargo run\n   Compiling hello_remote_world v0.1.0 (/workspaces/vscode-remote-try-rust)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/hello_remote_world`\nHello, VS Code Remote - Containers!"
  },
  {
    "objectID": "handouts/preparation/preparation.html#software-installation-optional",
    "href": "handouts/preparation/preparation.html#software-installation-optional",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "The following are installation steps for commands used by the author of this document. You may skip this section.\n\n\nText-mode interface for git\n% brew install tig\n\n\n\nA richer alternative to the top command. Used for visually monitoring CPU usage.\n% brew install htop\n\n\n\nCodex users may find this useful.\n% brew install ripgrep\n\n\n\nRequired if you want to view this document locally.\nSee Welcome to Quarto to learn more."
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d.html",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d.html",
    "title": "ElasticBalls2D Implementation Plan",
    "section": "",
    "text": "ElasticBalls2D Implementation Plan\n\nFor Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.\n\nGoal: Build a Julia package that simulates exact event-driven 2D elastic collisions among many balls and visualizes motion with Makie.\nArchitecture: Implement core types and deterministic event scheduling first, then analytic collision math, then simulation loop, then visualization layer. Keep queue correctness via per-ball version invalidation and verify behavior through TDD invariants.\nTech Stack: Julia 1.12, DataStructures.jl, StaticArrays.jl, CairoMakie.jl, Test\n\n\nTask 1: Package scaffold\nFiles: - Create: Project.toml - Create: src/ElasticBalls2D.jl - Create: test/runtests.jl\nStep 1: Write failing test - Add test/runtests.jl checks that package loads and exports expected API symbols.\nStep 2: Run test to verify it fails - Run: julia --project=. -e 'using Pkg; Pkg.test()' - Expected: fail due to missing types/functions.\nStep 3: Write minimal implementation - Add module and placeholder exports.\nStep 4: Run test to verify it passes - Run package tests.\n\n\nTask 2: Exact collision math\nFiles: - Modify: src/ElasticBalls2D.jl - Modify: test/runtests.jl\nStep 1: Write failing tests - Wall collision time tests for both axes and directions. - Ball-ball collision time tests for hit/miss/separating cases.\nStep 2: Run tests to fail - Run targeted tests.\nStep 3: Implement minimal math - Add analytic solvers with tolerances.\nStep 4: Run tests to pass - Re-run targeted tests.\n\n\nTask 3: Event engine and invariants\nFiles: - Modify: src/ElasticBalls2D.jl - Modify: test/runtests.jl\nStep 1: Write failing tests - Two-ball head-on elastic collision conserves kinetic energy. - Wall reflection flips one component. - Stale events get invalidated.\nStep 2: Run tests to fail - Run full suite.\nStep 3: Implement minimal engine - Add World, Event, queue scheduling, step_event!, simulate.\nStep 4: Run tests to pass - Run full suite.\n\n\nTask 4: Visualization API\nFiles: - Modify: src/ElasticBalls2D.jl - Modify: test/runtests.jl\nStep 1: Write failing tests - animate returns a figure object. - Recording path writes output file.\nStep 2: Run tests to fail - Run visualization tests.\nStep 3: Implement minimal visualization - Add Makie-based animation over simulated frames.\nStep 4: Run tests to pass - Run all tests.\n\n\nTask 5: Final verification\nFiles: - Modify: README.md\nStep 1: Add concise usage docs - Include setup, simulation, and animation examples.\nStep 2: Verification before completion - Run: julia --project=. -e 'using Pkg; Pkg.test()' - Run: julia --project=. -e 'using ElasticBalls2D' - Confirm no failures."
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html",
    "title": "Plan for Elastic Collisions Simulation",
    "section": "",
    "text": "Create a Rust crate to simulate and visualize 2D elastic collisions of multiple balls.\n\n\n\n\nLanguage: Rust\nVisualization: macroquad\nMath: glam (built-in to macroquad)\n\n\n\n\n\n\n\nBall: Position, Velocity, Radius, Mass, Color.\n\n\n\n\n\nMovement: velocity-based position updates.\nWall Collision: Bounce off edges.\nBall-Ball Collision:\n\nDistance check.\nStatic resolution (push apart).\nDynamic resolution (impulse response).\n\n\n\n\n\n\nMouse Interaction: Drag to spawn with velocity.\nSimulation Controls: Reset, Pause, Add random.\nVisual Polish: Gradient trails, FPS counter.\n\n\n\n\n\n\nProject Initialization\nBasic Physics Implementation\nCollision Resolution Logic\nInteractive UI and Controls\nUnit Tests\nREADME and Documentation"
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#goal",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#goal",
    "title": "Plan for Elastic Collisions Simulation",
    "section": "",
    "text": "Create a Rust crate to simulate and visualize 2D elastic collisions of multiple balls."
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#technology-stack",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#technology-stack",
    "title": "Plan for Elastic Collisions Simulation",
    "section": "",
    "text": "Language: Rust\nVisualization: macroquad\nMath: glam (built-in to macroquad)"
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#core-components",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#core-components",
    "title": "Plan for Elastic Collisions Simulation",
    "section": "",
    "text": "Ball: Position, Velocity, Radius, Mass, Color.\n\n\n\n\n\nMovement: velocity-based position updates.\nWall Collision: Bounce off edges.\nBall-Ball Collision:\n\nDistance check.\nStatic resolution (push apart).\nDynamic resolution (impulse response).\n\n\n\n\n\n\nMouse Interaction: Drag to spawn with velocity.\nSimulation Controls: Reset, Pause, Add random.\nVisual Polish: Gradient trails, FPS counter."
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#progress",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-gemini-3-pro-high/PLAN.html#progress",
    "title": "Plan for Elastic Collisions Simulation",
    "section": "",
    "text": "Project Initialization\nBasic Physics Implementation\nCollision Resolution Logic\nInteractive UI and Controls\nUnit Tests\nREADME and Documentation"
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html",
    "title": "Plan: Elastic Balls 2D Simulation Crate",
    "section": "",
    "text": "Create a Rust crate that simulates and visualizes elastic collisions of multiple balls in 2D space. The physics engine is separated from rendering for reusability.\n\n\n\nelastic-balls-2d/\n  Cargo.toml          # macroquad 0.4, rand 0.8\n  src/\n    lib.rs             # Physics engine (no macroquad dependency, uses macroquad::math::Vec2 directly)\n    main.rs            # Rendering + interaction via macroquad\nKey decision: Use macroquad::math::Vec2 in lib.rs. While this creates a compile-time dependency on macroquad, the math module is lightweight and avoids any glam version mismatch issues. The physics code itself uses no rendering — only the Vec2 type.\n\n\n\n\n\n\ncargo init --name elastic-balls-2d\nDependencies: macroquad = \"0.4\", rand = \"0.8\"\n\n\n\n\nStructs: - Ball — pos (Vec2), vel (Vec2), radius (f32), mass (f32), color ([f32; 4]) - Ball::new(pos, vel, radius, color) — mass = PI * r^2 - World — balls (Vec), width, height, paused, speed_multiplier - World::new(width, height) - World::add_ball(), clear(), ball_count(), resize() - World::update(dt) — sub-stepped simulation\nWall collisions: - Reflect velocity component (using .abs() to prevent double-reflection) - Clamp position to stay inside boundaries\nBall-ball collisions (O(n^2) pairwise): 1. Detect overlap: distance &lt; r1 + r2 2. Separate overlapping balls proportional to inverse mass 3. Compute impulse along collision normal (elastic, restitution = 1.0) 4. Update velocities: v1' = v1 + (j/m1)*n, v2' = v2 - (j/m2)*n 5. Skip if balls already separating (v_rel_along_normal &gt; 0)\nSub-stepping: Cap each sub-step at 1/120s to prevent tunneling at high speed multipliers.\n\n\n\nMain loop: input -&gt; resize -&gt; update -&gt; clear -&gt; draw -&gt; next_frame\nDrawing: - Balls as filled circles with white outline - Boundary rectangle - HUD: ball count, speed multiplier, FPS, pause state, controls help\nInput: - Left-click: spawn ball at cursor with random radius (10-40), velocity, and color - Space: pause/resume - R: reset (clear + respawn 5 initial balls) - Up/Down: increase/decrease speed multiplier (0.1x to 10x)\nInitial state: 5 random balls spawned on startup.\n\n\n\n\ncargo run — visual verification\nCheck wall bouncing, ball-ball collisions, interactivity\nVerify HUD displays correctly\n\n\n\n\n\n\nCargo.toml — project config with dependencies\nsrc/lib.rs — physics engine (~150 lines)\nsrc/main.rs — rendering and interaction (~120 lines)\n\n\n\n\n\ncargo build — compiles without errors\ncargo run — window opens, balls bounce, collisions look physically correct\nClick to add balls, Space to pause, R to reset, Up/Down to adjust speed\nBalls of different sizes should react proportionally (small balls bounce more)\nNo balls escape boundaries or get stuck together"
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#context",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#context",
    "title": "Plan: Elastic Balls 2D Simulation Crate",
    "section": "",
    "text": "Create a Rust crate that simulates and visualizes elastic collisions of multiple balls in 2D space. The physics engine is separated from rendering for reusability."
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#architecture",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#architecture",
    "title": "Plan: Elastic Balls 2D Simulation Crate",
    "section": "",
    "text": "elastic-balls-2d/\n  Cargo.toml          # macroquad 0.4, rand 0.8\n  src/\n    lib.rs             # Physics engine (no macroquad dependency, uses macroquad::math::Vec2 directly)\n    main.rs            # Rendering + interaction via macroquad\nKey decision: Use macroquad::math::Vec2 in lib.rs. While this creates a compile-time dependency on macroquad, the math module is lightweight and avoids any glam version mismatch issues. The physics code itself uses no rendering — only the Vec2 type."
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#implementation-steps",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#implementation-steps",
    "title": "Plan: Elastic Balls 2D Simulation Crate",
    "section": "",
    "text": "cargo init --name elastic-balls-2d\nDependencies: macroquad = \"0.4\", rand = \"0.8\"\n\n\n\n\nStructs: - Ball — pos (Vec2), vel (Vec2), radius (f32), mass (f32), color ([f32; 4]) - Ball::new(pos, vel, radius, color) — mass = PI * r^2 - World — balls (Vec), width, height, paused, speed_multiplier - World::new(width, height) - World::add_ball(), clear(), ball_count(), resize() - World::update(dt) — sub-stepped simulation\nWall collisions: - Reflect velocity component (using .abs() to prevent double-reflection) - Clamp position to stay inside boundaries\nBall-ball collisions (O(n^2) pairwise): 1. Detect overlap: distance &lt; r1 + r2 2. Separate overlapping balls proportional to inverse mass 3. Compute impulse along collision normal (elastic, restitution = 1.0) 4. Update velocities: v1' = v1 + (j/m1)*n, v2' = v2 - (j/m2)*n 5. Skip if balls already separating (v_rel_along_normal &gt; 0)\nSub-stepping: Cap each sub-step at 1/120s to prevent tunneling at high speed multipliers.\n\n\n\nMain loop: input -&gt; resize -&gt; update -&gt; clear -&gt; draw -&gt; next_frame\nDrawing: - Balls as filled circles with white outline - Boundary rectangle - HUD: ball count, speed multiplier, FPS, pause state, controls help\nInput: - Left-click: spawn ball at cursor with random radius (10-40), velocity, and color - Space: pause/resume - R: reset (clear + respawn 5 initial balls) - Up/Down: increase/decrease speed multiplier (0.1x to 10x)\nInitial state: 5 random balls spawned on startup.\n\n\n\n\ncargo run — visual verification\nCheck wall bouncing, ball-ball collisions, interactivity\nVerify HUD displays correctly"
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#files-to-createmodify",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#files-to-createmodify",
    "title": "Plan: Elastic Balls 2D Simulation Crate",
    "section": "",
    "text": "Cargo.toml — project config with dependencies\nsrc/lib.rs — physics engine (~150 lines)\nsrc/main.rs — rendering and interaction (~120 lines)"
  },
  {
    "objectID": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#verification",
    "href": "handouts/elastic-collisions/rust/elastic-balls-2d-claude-opus-4.6/plans/cached-popping-cake.html#verification",
    "title": "Plan: Elastic Balls 2D Simulation Crate",
    "section": "",
    "text": "cargo build — compiles without errors\ncargo run — window opens, balls bounce, collisions look physically correct\nClick to add balls, Space to pause, R to reset, Up/Down to adjust speed\nBalls of different sizes should react proportionally (small balls bounce more)\nNo balls escape boundaries or get stuck together"
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-claude-sonnet-4.6/docs/plans/2026-02-18-elastic-balls-2d.html",
    "href": "handouts/elastic-collisions/julia/elastic-balls-claude-sonnet-4.6/docs/plans/2026-02-18-elastic-balls-2d.html",
    "title": "ElasticBalls2D Implementation Plan",
    "section": "",
    "text": "For Claude: REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.\n\nGoal: Create a Julia package ElasticBalls2D that simulates perfectly elastic collisions of multiple balls (variable mass & radius) in 2D space and exports the result as an MP4/GIF animation.\nArchitecture: Immutable Ball structs (using StaticArrays.SVector) live in a mutable SimulationState. Each timestep performs Euler integration, wall reflection, then O(n²) ball-ball collision resolution. Visualization uses CairoMakie.record to export animation files.\nTech Stack: Julia 1.x, CairoMakie, StaticArrays, Colors, LinearAlgebra, Test (stdlib)\n\n\n\nFiles: - Create: Project.toml - Create: src/ElasticBalls2D.jl - Create: test/runtests.jl - Create: examples/basic_demo.jl\nStep 1: Create Project.toml\nname = \"ElasticBalls2D\"\nuuid = \"b1e2f3a4-c5d6-7890-abcd-ef1234567890\"\nversion = \"0.1.0\"\n\n[deps]\nCairoMakie = \"13f3f980-e62b-5c42-98c6-ff1f3baf88f0\"\nColors = \"5ae59095-9a9b-59fe-a467-6f913c188581\"\nLinearAlgebra = \"37e2e46d-f89d-539d-b4ee-838fcccc9c8e\"\nRandom = \"9a3f8284-a2c9-5f02-9a11-845980a1fd5c\"\nStaticArrays = \"90137ffa-7385-5640-81b9-e52037218182\"\n\n[compat]\njulia = \"1.9\"\nCairoMakie = \"0.10, 0.11, 0.12, 0.13, 0.14, 0.15\"\nColors = \"0.12, 0.13\"\nStaticArrays = \"1\"\n\n[extras]\nTest = \"8dfed614-e22c-5e08-85e1-65c5234f0b40\"\n\n[targets]\ntest = [\"Test\"]\nStep 2: Create minimal src/ElasticBalls2D.jl\nmodule ElasticBalls2D\n\nusing LinearAlgebra\nusing Random\nusing StaticArrays\nusing Colors\nusing CairoMakie\n\ninclude(\"types.jl\")\ninclude(\"physics.jl\")\ninclude(\"simulation.jl\")\ninclude(\"visualization.jl\")\n\nexport Vec2, Ball, BoundaryBox, SimulationState\nexport are_colliding, resolve_ball_collision, resolve_wall_collision\nexport step!, simulate!, random_balls\nexport record_simulation\n\nend # module\nStep 3: Create placeholder source files\nCreate src/types.jl, src/physics.jl, src/simulation.jl, src/visualization.jl — each with just a comment # TODO for now.\nStep 4: Create minimal test/runtests.jl\nusing Test\nusing ElasticBalls2D\n\n@testset \"ElasticBalls2D\" begin\n    @test true  # placeholder\nend\nStep 5: Instantiate dependencies\ncd /Users/atelierarith/work/atelierarith/CompPhysHack2026HandsOn/handouts/elastic-collisions/julia/elastic-balls-claude-sonnet-4.6\njulia --project=. -e 'using Pkg; Pkg.instantiate()'\nExpected: Dependencies resolve and download.\nStep 6: Run tests to verify structure\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: PASS with 1 test.\nStep 7: Commit\ngit add Project.toml src/ test/ examples/\ngit commit -m \"chore: initialize ElasticBalls2D package structure\"\n\n\n\n\nFiles: - Modify: src/types.jl - Modify: test/runtests.jl\nStep 1: Write failing tests for types\nReplace test/runtests.jl content:\nusing Test\nusing ElasticBalls2D\nusing StaticArrays\nusing Colors\n\n@testset \"ElasticBalls2D\" begin\n    @testset \"Types\" begin\n        # Ball construction\n        pos = Vec2(1.0, 2.0)\n        vel = Vec2(0.5, -0.3)\n        b = Ball(pos, vel, 1.0, 0.5, RGB{Float64}(1.0, 0.0, 0.0))\n        @test b.pos == pos\n        @test b.vel == vel\n        @test b.mass == 1.0\n        @test b.radius == 0.5\n\n        # Ball keyword constructor\n        b2 = Ball(pos=Vec2(0.0, 0.0))\n        @test b2.mass == 1.0\n        @test b2.radius == 0.5\n\n        # Invalid Ball\n        @test_throws ArgumentError Ball(pos, vel, -1.0, 0.5, RGB{Float64}(1.0, 0.0, 0.0))\n        @test_throws ArgumentError Ball(pos, vel, 1.0, 0.0, RGB{Float64}(1.0, 0.0, 0.0))\n\n        # BoundaryBox construction\n        box = BoundaryBox(0.0, 10.0, 0.0, 10.0)\n        @test box.xmin == 0.0\n        @test box.xmax == 10.0\n        @test_throws ArgumentError BoundaryBox(10.0, 0.0, 0.0, 10.0)\n\n        # SimulationState\n        balls = [Ball(pos=Vec2(2.0, 2.0), vel=Vec2(1.0, 0.0))]\n        state = SimulationState(balls)\n        @test state.time == 0.0\n        @test state.dt == 0.01\n        @test length(state.balls) == 1\n    end\nend\nStep 2: Run tests to verify they fail\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: FAIL — types not defined yet.\nStep 3: Implement src/types.jl\nusing StaticArrays\nusing Colors\nusing LinearAlgebra\n\n\"\"\"Stack-allocated 2D vector.\"\"\"\nconst Vec2 = SVector{2, Float64}\n\n\"\"\"Immutable ball with position, velocity, mass, radius, and color.\"\"\"\nstruct Ball\n    pos::Vec2\n    vel::Vec2\n    mass::Float64\n    radius::Float64\n    color::RGB{Float64}\n\n    function Ball(pos::Vec2, vel::Vec2, mass::Float64, radius::Float64, color::RGB{Float64})\n        mass &gt; 0 || throw(ArgumentError(\"mass must be positive, got $mass\"))\n        radius &gt; 0 || throw(ArgumentError(\"radius must be positive, got $radius\"))\n        new(pos, vel, mass, radius, color)\n    end\nend\n\n\"\"\"Keyword constructor with defaults.\"\"\"\nfunction Ball(; pos, vel=Vec2(0.0, 0.0), mass=1.0, radius=0.5,\n               color=RGB{Float64}(0.2, 0.6, 1.0))\n    Ball(Vec2(Float64.(pos)...), Vec2(Float64.(vel)...),\n         Float64(mass), Float64(radius), RGB{Float64}(color))\nend\n\n\"\"\"Rectangular simulation domain.\"\"\"\nstruct BoundaryBox\n    xmin::Float64\n    xmax::Float64\n    ymin::Float64\n    ymax::Float64\n\n    function BoundaryBox(xmin, xmax, ymin, ymax)\n        xmin &lt; xmax || throw(ArgumentError(\"xmin must be &lt; xmax\"))\n        ymin &lt; ymax || throw(ArgumentError(\"ymin must be &lt; ymax\"))\n        new(Float64(xmin), Float64(xmax), Float64(ymin), Float64(ymax))\n    end\nend\n\nBoundaryBox(; xmin=0.0, xmax=10.0, ymin=0.0, ymax=10.0) =\n    BoundaryBox(xmin, xmax, ymin, ymax)\n\n\"\"\"Mutable simulation state.\"\"\"\nmutable struct SimulationState\n    balls::Vector{Ball}\n    boundary::BoundaryBox\n    time::Float64\n    dt::Float64\n\n    function SimulationState(balls, boundary, time, dt)\n        dt &gt; 0 || throw(ArgumentError(\"dt must be positive, got $dt\"))\n        new(balls, boundary, Float64(time), Float64(dt))\n    end\nend\n\nSimulationState(balls::Vector{Ball}; boundary=BoundaryBox(), dt=0.01) =\n    SimulationState(balls, boundary, 0.0, dt)\nStep 4: Run tests to verify they pass\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: PASS.\nStep 5: Commit\ngit add src/types.jl test/runtests.jl\ngit commit -m \"feat: implement Ball, BoundaryBox, SimulationState types\"\n\n\n\n\nFiles: - Modify: src/physics.jl - Modify: test/runtests.jl\nStep 1: Add failing tests for wall collision\nAppend to the @testset \"ElasticBalls2D\" block in test/runtests.jl:\n    @testset \"Wall collisions\" begin\n        box = BoundaryBox(0.0, 10.0, 0.0, 10.0)\n\n        # Ball moving left through left wall\n        b = Ball(pos=Vec2(0.3, 5.0), vel=Vec2(-2.0, 0.0), radius=0.5)\n        b2 = resolve_wall_collision(b, box)\n        @test b2.vel[1] &gt; 0          # x-velocity flipped\n        @test b2.pos[1] &gt;= box.xmin + b.radius  # position inside\n\n        # Ball moving right through right wall\n        b = Ball(pos=Vec2(9.8, 5.0), vel=Vec2(2.0, 0.0), radius=0.5)\n        b2 = resolve_wall_collision(b, box)\n        @test b2.vel[1] &lt; 0\n        @test b2.pos[1] &lt;= box.xmax - b.radius\n\n        # Ball not touching wall — unchanged\n        b = Ball(pos=Vec2(5.0, 5.0), vel=Vec2(1.0, 1.0), radius=0.5)\n        b2 = resolve_wall_collision(b, box)\n        @test b2.pos == b.pos\n        @test b2.vel == b.vel\n    end\nStep 2: Run tests to verify they fail\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: FAIL — resolve_wall_collision not defined.\nStep 3: Implement resolve_wall_collision in src/physics.jl\n\"\"\"\n    resolve_wall_collision(ball, boundary) -&gt; Ball\n\nReflect ball off boundary walls: flip the velocity component and mirror position\nso the ball stays inside the box.\n\"\"\"\nfunction resolve_wall_collision(ball::Ball, boundary::BoundaryBox)\n    px, py = ball.pos\n    vx, vy = ball.vel\n    r = ball.radius\n\n    if px - r &lt; boundary.xmin\n        px = 2*(boundary.xmin + r) - px\n        vx = abs(vx)\n    elseif px + r &gt; boundary.xmax\n        px = 2*(boundary.xmax - r) - px\n        vx = -abs(vx)\n    end\n\n    if py - r &lt; boundary.ymin\n        py = 2*(boundary.ymin + r) - py\n        vy = abs(vy)\n    elseif py + r &gt; boundary.ymax\n        py = 2*(boundary.ymax - r) - py\n        vy = -abs(vy)\n    end\n\n    Ball(Vec2(px, py), Vec2(vx, vy), ball.mass, ball.radius, ball.color)\nend\nStep 4: Run tests to verify they pass\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: PASS.\nStep 5: Commit\ngit add src/physics.jl test/runtests.jl\ngit commit -m \"feat: implement wall collision reflection\"\n\n\n\n\nFiles: - Modify: src/physics.jl - Modify: test/runtests.jl\nStep 1: Add failing tests\nAppend to test/runtests.jl:\n    @testset \"Ball-ball collisions\" begin\n        # Head-on equal mass collision: velocities swap\n        b1 = Ball(pos=Vec2(4.0, 5.0), vel=Vec2(2.0, 0.0), mass=1.0, radius=0.4,\n                  color=RGB{Float64}(1.0, 0.0, 0.0))\n        b2 = Ball(pos=Vec2(5.0, 5.0), vel=Vec2(-2.0, 0.0), mass=1.0, radius=0.4,\n                  color=RGB{Float64}(0.0, 0.0, 1.0))\n        @test are_colliding(b1, b2)   # overlapping (dist=1.0 &lt; sum_radii=0.8... wait)\n\n        # Make sure they are colliding: dist=1.0, sum_radii=0.8 means NOT colliding\n        # Use radii=0.6 so sum=1.2 &gt; dist=1.0\n        b1 = Ball(pos=Vec2(4.0, 5.0), vel=Vec2(2.0, 0.0), mass=1.0, radius=0.6,\n                  color=RGB{Float64}(1.0, 0.0, 0.0))\n        b2 = Ball(pos=Vec2(5.0, 5.0), vel=Vec2(-2.0, 0.0), mass=1.0, radius=0.6,\n                  color=RGB{Float64}(0.0, 0.0, 1.0))\n        @test are_colliding(b1, b2)\n\n        p_before = b1.mass * b1.vel + b2.mass * b2.vel\n        ke_before = 0.5 * b1.mass * dot(b1.vel, b1.vel) + 0.5 * b2.mass * dot(b2.vel, b2.vel)\n\n        b1n, b2n = resolve_ball_collision(b1, b2)\n\n        p_after = b1n.mass * b1n.vel + b2n.mass * b2n.vel\n        ke_after = 0.5 * b1n.mass * dot(b1n.vel, b1n.vel) + 0.5 * b2n.mass * dot(b2n.vel, b2n.vel)\n\n        # Momentum conserved\n        @test p_after ≈ p_before  atol=1e-10\n        # Kinetic energy conserved (elastic)\n        @test ke_after ≈ ke_before  atol=1e-10\n        # Balls no longer overlap after separation\n        dx = b1n.pos - b2n.pos\n        dist = sqrt(dot(dx, dx))\n        @test dist &gt;= b1n.radius + b2n.radius - 1e-10\n\n        # Non-colliding balls: unchanged\n        b3 = Ball(pos=Vec2(0.0, 0.0), vel=Vec2(1.0, 0.0), radius=0.3,\n                  color=RGB{Float64}(0.0, 1.0, 0.0))\n        b4 = Ball(pos=Vec2(5.0, 5.0), vel=Vec2(-1.0, 0.0), radius=0.3,\n                  color=RGB{Float64}(1.0, 0.0, 0.0))\n        @test !are_colliding(b3, b4)\n    end\nStep 2: Run tests to verify they fail\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: FAIL — are_colliding, resolve_ball_collision not defined.\nStep 3: Implement ball-ball collision functions in src/physics.jl\nAppend to src/physics.jl:\n\"\"\"\n    are_colliding(b1, b2) -&gt; Bool\n\nReturn true if the two balls overlap (sum of radii &gt; distance between centers).\nUses squared distance to avoid sqrt.\n\"\"\"\nfunction are_colliding(b1::Ball, b2::Ball)\n    dx = b1.pos - b2.pos\n    min_dist = b1.radius + b2.radius\n    return dot(dx, dx) &lt;= min_dist * min_dist\nend\n\n\"\"\"\n    resolve_ball_collision(b1, b2) -&gt; (Ball, Ball)\n\nResolve a perfectly elastic 2D collision. Returns updated balls with:\n- new velocities from the elastic collision formula\n- positions separated so they no longer overlap\n\nOnly acts if the balls are approaching each other.\n\"\"\"\nfunction resolve_ball_collision(b1::Ball, b2::Ball)\n    dx = b1.pos - b2.pos\n    dist_sq = dot(dx, dx)\n\n    # Degenerate case: coincident centers\n    dist_sq &lt; eps(Float64) && return b1, b2\n\n    dv = b1.vel - b2.vel\n\n    # Only resolve if approaching (dot(dv, dx) &lt; 0)\n    dot(dv, dx) &gt;= 0 && return b1, b2\n\n    m1, m2 = b1.mass, b2.mass\n    total_mass = m1 + m2\n    factor = dot(dv, dx) / dist_sq\n\n    v1_new = b1.vel - (2m2 / total_mass) * factor * dx\n    v2_new = b2.vel + (2m1 / total_mass) * factor * dx\n\n    # Positional separation along collision normal\n    dist = sqrt(dist_sq)\n    overlap = (b1.radius + b2.radius) - dist\n    if overlap &gt; 0\n        normal = dx / dist\n        p1 = b1.pos + (m2 / total_mass) * overlap * normal\n        p2 = b2.pos - (m1 / total_mass) * overlap * normal\n    else\n        p1, p2 = b1.pos, b2.pos\n    end\n\n    Ball(p1, v1_new, m1, b1.radius, b1.color),\n    Ball(p2, v2_new, m2, b2.radius, b2.color)\nend\nStep 4: Run tests to verify they pass\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: PASS.\nStep 5: Commit\ngit add src/physics.jl test/runtests.jl\ngit commit -m \"feat: implement ball-ball elastic collision detection and resolution\"\n\n\n\n\nFiles: - Modify: src/simulation.jl - Modify: test/runtests.jl\nStep 1: Add failing tests\nAppend to test/runtests.jl:\n    @testset \"Simulation\" begin\n        using LinearAlgebra\n        box = BoundaryBox(0.0, 10.0, 0.0, 10.0)\n        b1 = Ball(pos=Vec2(3.0, 5.0), vel=Vec2(1.0, 0.5), mass=1.0, radius=0.3,\n                  color=RGB{Float64}(1.0, 0.0, 0.0))\n        b2 = Ball(pos=Vec2(7.0, 5.0), vel=Vec2(-1.0, -0.5), mass=1.0, radius=0.3,\n                  color=RGB{Float64}(0.0, 0.0, 1.0))\n        state = SimulationState([b1, b2]; boundary=box, dt=0.01)\n\n        # Total momentum before (no external forces: should be conserved)\n        p_init = sum(b.mass * b.vel for b in state.balls)\n\n        simulate!(state, 2.0)  # run for 2 seconds\n\n        p_final = sum(b.mass * b.vel for b in state.balls)\n        @test p_final ≈ p_init  atol=1e-8\n\n        # Time advanced\n        @test state.time ≈ 2.0  atol=1e-10\n\n        # random_balls produces non-overlapping balls\n        balls = random_balls(5; boundary=box)\n        @test length(balls) == 5\n        for i in 1:5, j in (i+1):5\n            dx = balls[i].pos - balls[j].pos\n            dist = sqrt(dot(dx, dx))\n            @test dist &gt;= balls[i].radius + balls[j].radius - 1e-8\n        end\n    end\nStep 2: Run tests to verify they fail\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: FAIL — simulate!, random_balls not defined.\nStep 3: Implement src/simulation.jl\n\"\"\"\n    step!(state) -&gt; SimulationState\n\nAdvance simulation one timestep: integrate positions (Euler), resolve wall\ncollisions, then resolve all pairwise ball-ball collisions (O(n²)).\n\"\"\"\nfunction step!(state::SimulationState)\n    dt = state.dt\n    n = length(state.balls)\n    balls = state.balls\n\n    # Euler integration\n    new_balls = Vector{Ball}(undef, n)\n    for i in 1:n\n        b = balls[i]\n        new_balls[i] = Ball(b.pos + b.vel * dt, b.vel, b.mass, b.radius, b.color)\n    end\n\n    # Wall collisions\n    for i in 1:n\n        new_balls[i] = resolve_wall_collision(new_balls[i], state.boundary)\n    end\n\n    # Ball-ball collisions (all pairs)\n    for i in 1:n\n        for j in (i+1):n\n            if are_colliding(new_balls[i], new_balls[j])\n                new_balls[i], new_balls[j] = resolve_ball_collision(new_balls[i], new_balls[j])\n            end\n        end\n    end\n\n    state.balls = new_balls\n    state.time += dt\n    return state\nend\n\n\"\"\"\n    simulate!(state, duration) -&gt; SimulationState\n\nRun simulation for `duration` time units in-place. Returns the modified state.\n\"\"\"\nfunction simulate!(state::SimulationState, duration::Real)\n    nsteps = round(Int, duration / state.dt)\n    for _ in 1:nsteps\n        step!(state)\n    end\n    return state\nend\n\n\"\"\"\n    random_balls(n; boundary, rng, radius_range, speed_range, mass_range) -&gt; Vector{Ball}\n\nGenerate `n` non-overlapping random balls with evenly-spaced hue colors.\n\"\"\"\nfunction random_balls(n::Int;\n    boundary  = BoundaryBox(),\n    rng       = Random.GLOBAL_RNG,\n    radius_range = (0.2, 0.5),\n    speed_range  = (0.5, 3.0),\n    mass_range   = (0.5, 2.0),\n)\n    balls  = Ball[]\n    hues   = range(0.0, 360.0; length=n+1)[1:n]\n\n    for i in 1:n\n        color  = RGB{Float64}(HSV(hues[i], 0.85, 0.95))\n        radius = radius_range[1] + rand(rng) * (radius_range[2] - radius_range[1])\n        mass   = mass_range[1]   + rand(rng) * (mass_range[2]   - mass_range[1])\n        speed  = speed_range[1]  + rand(rng) * (speed_range[2]  - speed_range[1])\n        angle  = rand(rng) * 2π\n        vel    = Vec2(speed * cos(angle), speed * sin(angle))\n\n        placed = false\n        for _ in 1:2000\n            px = boundary.xmin + radius + rand(rng) * (boundary.xmax - boundary.xmin - 2radius)\n            py = boundary.ymin + radius + rand(rng) * (boundary.ymax - boundary.ymin - 2radius)\n            pos = Vec2(px, py)\n            if all(dot(pos - b.pos, pos - b.pos) &gt; (radius + b.radius)^2 for b in balls)\n                push!(balls, Ball(pos, vel, mass, radius, color))\n                placed = true\n                break\n            end\n        end\n        placed || error(\"Could not place ball $i — try fewer balls or a larger boundary\")\n    end\n    return balls\nend\nStep 4: Run tests to verify they pass\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: PASS.\nStep 5: Commit\ngit add src/simulation.jl test/runtests.jl\ngit commit -m \"feat: implement simulation step loop and random_balls generator\"\n\n\n\n\nFiles: - Modify: src/visualization.jl\nNo new tests — CairoMakie rendering is integration-tested via the example.\nStep 1: Implement src/visualization.jl\nusing CairoMakie\n\n\"\"\"\n    record_simulation(state, filename; duration, framerate, substeps, resolution)\n\nSimulate and record to `filename` (MP4 or GIF). Each frame advances `substeps`\nsimulation steps (auto-computed from `dt` and `framerate` if not given).\n\n# Arguments\n- `state`: `SimulationState` (will be mutated)\n- `filename`: output path, e.g. `\"simulation.mp4\"` or `\"animation.gif\"`\n- `duration`: wall-clock duration of the animation in seconds (default 5.0)\n- `framerate`: frames per second (default 30)\n- `substeps`: simulation steps per frame (default: `round(Int, 1/(framerate*dt))`)\n- `resolution`: figure size in pixels, e.g. `(800, 800)`\n\"\"\"\nfunction record_simulation(state::SimulationState, filename::AbstractString;\n    duration    = 5.0,\n    framerate   = 30,\n    substeps    = nothing,\n    resolution  = (800, 800),\n)\n    boundary = state.boundary\n    if substeps === nothing\n        substeps = max(1, round(Int, 1.0 / (framerate * state.dt)))\n    end\n    nframes = round(Int, duration * framerate)\n\n    positions = Observable(Point2f[Point2f(b.pos...) for b in state.balls])\n    radii     = Observable(Float32[b.radius for b in state.balls])\n    colors    = Observable([b.color for b in state.balls])\n\n    fig = Figure(; size=resolution)\n    ax  = Axis(fig[1, 1];\n        aspect = DataAspect(),\n        limits = (boundary.xmin, boundary.xmax, boundary.ymin, boundary.ymax),\n        title  = \"Elastic Balls 2D\",\n        xlabel = \"x\", ylabel = \"y\",\n    )\n\n    scatter!(ax, positions;\n        color      = colors,\n        markersize = radii,  # radius in data units\n        markerspace = :data,\n        marker     = Circle,\n        strokewidth = 1,\n        strokecolor = :black,\n    )\n\n    record(fig, filename; framerate=framerate) do io\n        for _ in 1:nframes\n            for _ in 1:substeps\n                step!(state)\n            end\n            positions[] = Point2f[Point2f(b.pos...) for b in state.balls]\n            radii[]     = Float32[b.radius for b in state.balls]\n            colors[]    = [b.color for b in state.balls]\n            recordframe!(io)\n        end\n    end\n\n    return filename\nend\nStep 2: Run existing tests to make sure nothing broke\njulia --project=. -e 'using Pkg; Pkg.test()'\nExpected: PASS.\nStep 3: Commit\ngit add src/visualization.jl\ngit commit -m \"feat: implement CairoMakie animation export (MP4/GIF)\"\n\n\n\n\nFiles: - Modify: examples/basic_demo.jl\nStep 1: Write examples/basic_demo.jl\nusing ElasticBalls2D\nusing Random\n\n# Reproducible\nrng = MersenneTwister(42)\n\nboundary = BoundaryBox(; xmin=0.0, xmax=12.0, ymin=0.0, ymax=12.0)\nballs    = random_balls(10; boundary=boundary, rng=rng)\nstate    = SimulationState(balls; boundary=boundary, dt=0.005)\n\noutfile = joinpath(@__DIR__, \"elastic_balls.mp4\")\nprintln(\"Recording to $outfile ...\")\nrecord_simulation(state, outfile; duration=8.0, framerate=30)\nprintln(\"Done! Open $outfile to view the animation.\")\nStep 2: Run the example end-to-end\njulia --project=. examples/basic_demo.jl\nExpected: MP4 file created at examples/elastic_balls.mp4. Inspect visually.\nStep 3: Commit\ngit add examples/basic_demo.jl\ngit commit -m \"feat: add basic_demo example for end-to-end verification\"\n\n\n\n\n\n\n\nTask\nWhat it delivers\n\n\n\n\n1\nPackage scaffold + Pkg.instantiate\n\n\n2\nBall, BoundaryBox, SimulationState types with validation\n\n\n3\nWall-reflection physics (tested)\n\n\n4\nBall-ball elastic collision (momentum + KE conserved, tested)\n\n\n5\nSimulation loop + random_balls generator (tested)\n\n\n6\nCairoMakie MP4/GIF export\n\n\n7\nEnd-to-end example"
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-claude-sonnet-4.6/docs/plans/2026-02-18-elastic-balls-2d.html#summary",
    "href": "handouts/elastic-collisions/julia/elastic-balls-claude-sonnet-4.6/docs/plans/2026-02-18-elastic-balls-2d.html#summary",
    "title": "ElasticBalls2D Implementation Plan",
    "section": "",
    "text": "Task\nWhat it delivers\n\n\n\n\n1\nPackage scaffold + Pkg.instantiate\n\n\n2\nBall, BoundaryBox, SimulationState types with validation\n\n\n3\nWall-reflection physics (tested)\n\n\n4\nBall-ball elastic collision (momentum + KE conserved, tested)\n\n\n5\nSimulation loop + random_balls generator (tested)\n\n\n6\nCairoMakie MP4/GIF export\n\n\n7\nEnd-to-end example"
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html",
    "title": "ElasticBalls2D Design",
    "section": "",
    "text": "Build a Julia package for accurate simulation and visualization of many 2D elastic balls with: - Event-driven exact collision timing - Reflective rectangular walls - Per-ball mass and radius - Makie-based animation\n\n\n\nThe package is split into four concerns: - Types: Ball, World, and Event types - Physics: exact collision-time solvers and elastic collision response - Engine: event queue, invalidation, and simulation loop - Viz: Makie animation helpers\nWorld holds all balls, bounds, the current simulation time, tolerances, and an event queue. Events are immutable records for :ball_ball, :wall_x, and :wall_y. Every ball carries a version counter; event records capture versions at scheduling time. When an event is popped, version mismatch means the event is stale and skipped.\n\n\n\n\nCreate world from initial state, validate radii/masses and no initial overlaps.\nSeed queue with wall and pair collision candidates.\nPop earliest valid event.\nAdvance all positions exactly to event time.\nResolve collision with analytic elastic equations.\nIncrement versions for affected balls and schedule new candidates.\nRepeat until requested end time.\n\nThis flow guarantees deterministic simulation for identical inputs and avoids stale-event corruption.\n\n\n\nBall-ball collision times are found from the first nonnegative root of ||Δx + Δv t|| = r_i + r_j, which yields a quadratic. Reject events when discriminant is negative, relative speed is near zero, or root is nonpositive.\nWall collision times are linear in each axis using signed velocity direction and ball radius.\nResolution uses 2D impulse equations for perfectly elastic collisions with arbitrary masses. Small tolerances (eps_time, eps_dist) avoid jitter from floating-point roundoff.\n\n\n\nUse TDD for every behavior: - Unit: ball-ball time solver, wall times, wall reflection, two-body impulse invariants - Queue: stale event invalidation correctness - Integration: deterministic replay, no penetration, bounded kinetic-energy drift - Visualization: smoke tests for figure creation and optional recording path"
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#scope",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#scope",
    "title": "ElasticBalls2D Design",
    "section": "",
    "text": "Build a Julia package for accurate simulation and visualization of many 2D elastic balls with: - Event-driven exact collision timing - Reflective rectangular walls - Per-ball mass and radius - Makie-based animation"
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#architecture",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#architecture",
    "title": "ElasticBalls2D Design",
    "section": "",
    "text": "The package is split into four concerns: - Types: Ball, World, and Event types - Physics: exact collision-time solvers and elastic collision response - Engine: event queue, invalidation, and simulation loop - Viz: Makie animation helpers\nWorld holds all balls, bounds, the current simulation time, tolerances, and an event queue. Events are immutable records for :ball_ball, :wall_x, and :wall_y. Every ball carries a version counter; event records capture versions at scheduling time. When an event is popped, version mismatch means the event is stale and skipped."
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#data-flow",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#data-flow",
    "title": "ElasticBalls2D Design",
    "section": "",
    "text": "Create world from initial state, validate radii/masses and no initial overlaps.\nSeed queue with wall and pair collision candidates.\nPop earliest valid event.\nAdvance all positions exactly to event time.\nResolve collision with analytic elastic equations.\nIncrement versions for affected balls and schedule new candidates.\nRepeat until requested end time.\n\nThis flow guarantees deterministic simulation for identical inputs and avoids stale-event corruption."
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#numerics",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#numerics",
    "title": "ElasticBalls2D Design",
    "section": "",
    "text": "Ball-ball collision times are found from the first nonnegative root of ||Δx + Δv t|| = r_i + r_j, which yields a quadratic. Reject events when discriminant is negative, relative speed is near zero, or root is nonpositive.\nWall collision times are linear in each axis using signed velocity direction and ball radius.\nResolution uses 2D impulse equations for perfectly elastic collisions with arbitrary masses. Small tolerances (eps_time, eps_dist) avoid jitter from floating-point roundoff."
  },
  {
    "objectID": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#testing-strategy",
    "href": "handouts/elastic-collisions/julia/elastic-balls-codex-gpt-5.3/docs/plans/2026-02-09-elastic-balls-2d-design.html#testing-strategy",
    "title": "ElasticBalls2D Design",
    "section": "",
    "text": "Use TDD for every behavior: - Unit: ball-ball time solver, wall times, wall reflection, two-body impulse invariants - Queue: stale event invalidation correctness - Integration: deterministic replay, no penetration, bounded kinetic-energy drift - Visualization: smoke tests for figure creation and optional recording path"
  },
  {
    "objectID": "handouts/preparation/preparation-ja.html",
    "href": "handouts/preparation/preparation-ja.html",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "この資料は CompPhysHack 2026 のために作成された．\n人間は自然言語で作りたいものを指示し AI Agent はソースコードを生成・コマンドの実行を行う．このような AI を用いて開発を効率よく進める手法を AI-driven 開発と呼ぶ. Vibe coding, Agentic engineering, Agentic coding などのような言い方も存在する．\n試すのは非常に簡単である．好きなプラットフォーマが提供している AI Agent をインストールし下記のプロンプトを試すとよい．\nFor Julia users:\nI want to create a Julia package for simulating and visualizing elastic collisions of multiple balls in 2D space.\nFor Rust users:\nI want to create a Rust crate for simulating and visualizing elastic collisions of multiple balls in 2D space.\nここでは英語によるプロンプトを用いたが，日本語など，好きな自然言語で指示ができる．例えばこのような出力が期待できる．ソースコード生成には Cursor が提供している Composer 1.5 モデルを用いた．\n\n\n\n\nAI Agent は常に進化しているので答えはない．良いスタート地点はどのアカウントを持っているかによる．または近くの同僚・友達に聞いてみるとよい．\n\nChatGPT を契約していれば Codex, GPT-5.3-Codex を使ってみる\nClaude を契約していれば Claude Code: Opus-4.6 を使ってみる\n\nとにかく無料で使いたい\n\nGitHub Copilot\n\nGemini CLI\nGoogle Antigravity を使う\n\n\nどのサービスも使用上限が存在する. すべてはお金次第. CompPhysHack 2026 参加者が全日程を楽しむには何かしらの有料プランに加入する必要があるだろう．\n\nこの資料を作成している筆者の場合，下記のような構成である．\n\nClaude Code MAX $200/$100: Opus-4.6\n\nCoding を AI に任せている\n\nChatGPT Plus plan $20: Codex: GPT-5.3\n\nClaude Code とは別の視点が欲しい\n\nCursor Pro plan $20: 日常のエディタとして Composer 1.5\n\nソースコードの補完が得意. 統合ターミナルでのエラー出力を AI エージェントにシームレスに渡せるのがユーザ体験が良い\n\n\n\n\n\nCompPhysHack 2026 の参加者はある程度ソフトウェア開発経験があることを想定している．ここでは CLI ツールを経由して各種 AI エージェントをインストールしよう．\n\n\nnpm は Node.js のためのパッケージマネージャである. Node.js は JavaScript ランタイムである. Codex CLI, Gemini CLI をインストールするにはこの手順が必要である．\n\nDownload Node.js の指示に従うこと．\n\n以下は各種 CLI ツールの導入について書いているが，全てを導入する必要はない．\n\n\n\n\nhttps://developers.openai.com/codex/cli/\n\n$ npm i -g @openai/codex\n$ codex\n利用するには ChatGPT を契約しているアカウントが必要である．\n\n\n\n$ npm install -g @google/gemini-cli\n$ gemini\nSee https://github.com/google-gemini/gemini-cli to learn more.\n利用するには Google アカウントが必要である．\n\n\n\nmacOS, Linux, WSL:\n$ curl -fsSL https://claude.ai/install.sh | bash\n$ claude\nWindows PowerShell:\nPS&gt; irm https://claude.ai/install.ps1 | iex\n\n\n\n$ npm install -g @github/copilot\n$ copilot\nSee https://github.com/github/copilot-cli to learn more.\n\n\n\n\nVS Code または派生の Cursor, Google Antigravity を導入する．全て入れる必要はない．\n\n\n下記のリンク先の指示に従う\n\nhttps://code.visualstudio.com/download\nhttps://github.com/features/copilot\n\n\n\n\n下記のリンク先の指示に従う\nhttps://cursor.com/download\nまた cursor-agent で Cursor を CLI ツールとして利用できる．\n\n\n\n下記リンク先の指示に従う\nhttps://antigravity.google/download\n\n\n\n\nここでは現代的な一般的なソフトウェア開発(数値計算もこのカテゴリの中に入る)で有用な CLI ツールを導入する．\n\n\n多くの AI エージェントは gh コマンドを経由して GitHub にある Issue の作成，プルリクエストの作成を行う．これにより多くの面倒な作業を自動化することができる．\nインストールするには https://cli.github.com/ にある説明を読むこと\nmacOS\n% brew install gh\nLinux ユーザは Installing gh on Linux and BSD を参考に導入すること．\nWindows ユーザは Installing gh on Windows を参考に導入すること．\n\n\n\nJulia は科学技術計算が得意な汎用プログラミング言語である．\nInstalling Julia の指示に従う.\nmacOS or Linux:\n$ curl -fsSL https://install.julialang.org | sh\nWindows:\nPS&gt; winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n\n\n\nRust はシステムプログラミング向けに開発されているが，科学技術計算でも注目されている．Install Rust の指示に従う．\nmacOS or Linux:\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nSee this instructions if you are using Windows.\n上記のコマンドで cargo, rustc のようなコマンドが使えるようになる．動作確認は次のとおり．\n$ cargo new hello-world\n$ cd hello-world\n$ cargo run --release\ncargo run --release\n   Compiling hello-world v0.1.0 (path/to/your-workspace/hello-world)\n    Finished `release` profile [optimized] target(s) in 1.38s\n     Running `target/release/hello-world`\nHello, world!\n\n\n\nPython はスクリプト言語として優秀であるが，パッケージマネージャが乱立しており多くの混乱をコミュニティに招いている．uv はそれに終止符を打つであろう．私はそのように願っている．uv は Python の高速なパッケージマネージャである．uv は Rust で実装されている．\nInstalling uv の指示に従う．\nmacOS or Linux:\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n動作確認\n$ mkdir path/to/your-workspace\n$ cd path/to/your-workspace\n$ uv init\n$ uv run python main.py\n\n\n\nClaude Code や Codex はユーザからの許可をバイパスするオプションを備えている．たとえば --allow-dangerously-skip-permissions, --yolo といったオプションだ．このようなオプションは便利だが rm -rf / のような危険なコマンドの実行も許すことになる．このような状況を防ぐためにサンドボックス環境を使うのが望ましい．たとえば Docker が提供するコンテナはマウントするファイルを制限することで制限された範囲で AI Agent を行動させることが可能である．\nOS に応じてインストールすること:\n\nInstall Docker Desktop on Windows\nInstall Docker Desktop on Mac\nInstall Docker Desktop on Linux\n\n動作確認は下記のコマンドでできる:\n$ docker run --rm hello-world\n\n\n\nDocker を使って環境構築するには Dockerfile を作る必要がある．何もないところから構築するのは大変である．そこで Devcontainer が提供する Development Container Features を利用することで，Feature と呼ばれる自己完結した設定をブロックとして組み立てて環境構築することにする．これにより Docker コンテナ内部で Julia, Python, Rust などを自由に使うことができる．\nDev Container CLI に従って下記のようにインストールする．\n$ npm install -g @devcontainers/cli\n下記のコマンドで確かめることができる.\n$ git clone https://github.com/microsoft/vscode-remote-try-rust\n$ cd vscode-remote-try-rust\n$ devcontainer build\n$ devcontainer up --workspace-folder ./\n$ devcontainer exec --workspace-folder ./ bash\nvscode ➜ /workspaces/vscode-remote-try-rust (main) $ cargo run\n   Compiling hello_remote_world v0.1.0 (/workspaces/vscode-remote-try-rust)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/hello_remote_world`\nHello, VS Code Remote - Containers!\n\n\n\n\n下記はこの資料の作成者が使っているコマンドをインストールするための手順である．読まなくてよい．\n\n\nText-mode interface for git\n% brew install tig\n\n\n\nリッチな top コマンド．CPU 利用率を目視で計測するために用いている．\n% brew install htop\n\n\n\nCodex ユーザは入れてもよいかもしれない．\n% brew install ripgrep\n\n\n\nこの資料をローカルで見たい場合には必要\nSee Welcome to Quarto to learn more."
  },
  {
    "objectID": "handouts/preparation/preparation-ja.html#どのツールを使うべきか",
    "href": "handouts/preparation/preparation-ja.html#どのツールを使うべきか",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "AI Agent は常に進化しているので答えはない．良いスタート地点はどのアカウントを持っているかによる．または近くの同僚・友達に聞いてみるとよい．\n\nChatGPT を契約していれば Codex, GPT-5.3-Codex を使ってみる\nClaude を契約していれば Claude Code: Opus-4.6 を使ってみる\n\nとにかく無料で使いたい\n\nGitHub Copilot\n\nGemini CLI\nGoogle Antigravity を使う\n\n\nどのサービスも使用上限が存在する. すべてはお金次第. CompPhysHack 2026 参加者が全日程を楽しむには何かしらの有料プランに加入する必要があるだろう．\n\nこの資料を作成している筆者の場合，下記のような構成である．\n\nClaude Code MAX $200/$100: Opus-4.6\n\nCoding を AI に任せている\n\nChatGPT Plus plan $20: Codex: GPT-5.3\n\nClaude Code とは別の視点が欲しい\n\nCursor Pro plan $20: 日常のエディタとして Composer 1.5\n\nソースコードの補完が得意. 統合ターミナルでのエラー出力を AI エージェントにシームレスに渡せるのがユーザ体験が良い"
  },
  {
    "objectID": "handouts/preparation/preparation-ja.html#command-line-interface-cli-ツールの導入",
    "href": "handouts/preparation/preparation-ja.html#command-line-interface-cli-ツールの導入",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "CompPhysHack 2026 の参加者はある程度ソフトウェア開発経験があることを想定している．ここでは CLI ツールを経由して各種 AI エージェントをインストールしよう．\n\n\nnpm は Node.js のためのパッケージマネージャである. Node.js は JavaScript ランタイムである. Codex CLI, Gemini CLI をインストールするにはこの手順が必要である．\n\nDownload Node.js の指示に従うこと．\n\n以下は各種 CLI ツールの導入について書いているが，全てを導入する必要はない．\n\n\n\n\nhttps://developers.openai.com/codex/cli/\n\n$ npm i -g @openai/codex\n$ codex\n利用するには ChatGPT を契約しているアカウントが必要である．\n\n\n\n$ npm install -g @google/gemini-cli\n$ gemini\nSee https://github.com/google-gemini/gemini-cli to learn more.\n利用するには Google アカウントが必要である．\n\n\n\nmacOS, Linux, WSL:\n$ curl -fsSL https://claude.ai/install.sh | bash\n$ claude\nWindows PowerShell:\nPS&gt; irm https://claude.ai/install.ps1 | iex\n\n\n\n$ npm install -g @github/copilot\n$ copilot\nSee https://github.com/github/copilot-cli to learn more."
  },
  {
    "objectID": "handouts/preparation/preparation-ja.html#ai-付属統合開発環境の導入",
    "href": "handouts/preparation/preparation-ja.html#ai-付属統合開発環境の導入",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "VS Code または派生の Cursor, Google Antigravity を導入する．全て入れる必要はない．\n\n\n下記のリンク先の指示に従う\n\nhttps://code.visualstudio.com/download\nhttps://github.com/features/copilot\n\n\n\n\n下記のリンク先の指示に従う\nhttps://cursor.com/download\nまた cursor-agent で Cursor を CLI ツールとして利用できる．\n\n\n\n下記リンク先の指示に従う\nhttps://antigravity.google/download"
  },
  {
    "objectID": "handouts/preparation/preparation-ja.html#software-installation",
    "href": "handouts/preparation/preparation-ja.html#software-installation",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "ここでは現代的な一般的なソフトウェア開発(数値計算もこのカテゴリの中に入る)で有用な CLI ツールを導入する．\n\n\n多くの AI エージェントは gh コマンドを経由して GitHub にある Issue の作成，プルリクエストの作成を行う．これにより多くの面倒な作業を自動化することができる．\nインストールするには https://cli.github.com/ にある説明を読むこと\nmacOS\n% brew install gh\nLinux ユーザは Installing gh on Linux and BSD を参考に導入すること．\nWindows ユーザは Installing gh on Windows を参考に導入すること．\n\n\n\nJulia は科学技術計算が得意な汎用プログラミング言語である．\nInstalling Julia の指示に従う.\nmacOS or Linux:\n$ curl -fsSL https://install.julialang.org | sh\nWindows:\nPS&gt; winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore\n\n\n\nRust はシステムプログラミング向けに開発されているが，科学技術計算でも注目されている．Install Rust の指示に従う．\nmacOS or Linux:\n$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nSee this instructions if you are using Windows.\n上記のコマンドで cargo, rustc のようなコマンドが使えるようになる．動作確認は次のとおり．\n$ cargo new hello-world\n$ cd hello-world\n$ cargo run --release\ncargo run --release\n   Compiling hello-world v0.1.0 (path/to/your-workspace/hello-world)\n    Finished `release` profile [optimized] target(s) in 1.38s\n     Running `target/release/hello-world`\nHello, world!\n\n\n\nPython はスクリプト言語として優秀であるが，パッケージマネージャが乱立しており多くの混乱をコミュニティに招いている．uv はそれに終止符を打つであろう．私はそのように願っている．uv は Python の高速なパッケージマネージャである．uv は Rust で実装されている．\nInstalling uv の指示に従う．\nmacOS or Linux:\n$ curl -LsSf https://astral.sh/uv/install.sh | sh\n動作確認\n$ mkdir path/to/your-workspace\n$ cd path/to/your-workspace\n$ uv init\n$ uv run python main.py\n\n\n\nClaude Code や Codex はユーザからの許可をバイパスするオプションを備えている．たとえば --allow-dangerously-skip-permissions, --yolo といったオプションだ．このようなオプションは便利だが rm -rf / のような危険なコマンドの実行も許すことになる．このような状況を防ぐためにサンドボックス環境を使うのが望ましい．たとえば Docker が提供するコンテナはマウントするファイルを制限することで制限された範囲で AI Agent を行動させることが可能である．\nOS に応じてインストールすること:\n\nInstall Docker Desktop on Windows\nInstall Docker Desktop on Mac\nInstall Docker Desktop on Linux\n\n動作確認は下記のコマンドでできる:\n$ docker run --rm hello-world\n\n\n\nDocker を使って環境構築するには Dockerfile を作る必要がある．何もないところから構築するのは大変である．そこで Devcontainer が提供する Development Container Features を利用することで，Feature と呼ばれる自己完結した設定をブロックとして組み立てて環境構築することにする．これにより Docker コンテナ内部で Julia, Python, Rust などを自由に使うことができる．\nDev Container CLI に従って下記のようにインストールする．\n$ npm install -g @devcontainers/cli\n下記のコマンドで確かめることができる.\n$ git clone https://github.com/microsoft/vscode-remote-try-rust\n$ cd vscode-remote-try-rust\n$ devcontainer build\n$ devcontainer up --workspace-folder ./\n$ devcontainer exec --workspace-folder ./ bash\nvscode ➜ /workspaces/vscode-remote-try-rust (main) $ cargo run\n   Compiling hello_remote_world v0.1.0 (/workspaces/vscode-remote-try-rust)\n    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.45s\n     Running `target/debug/hello_remote_world`\nHello, VS Code Remote - Containers!"
  },
  {
    "objectID": "handouts/preparation/preparation-ja.html#software-installation-optional",
    "href": "handouts/preparation/preparation-ja.html#software-installation-optional",
    "title": "Software installation for Agentic coding",
    "section": "",
    "text": "下記はこの資料の作成者が使っているコマンドをインストールするための手順である．読まなくてよい．\n\n\nText-mode interface for git\n% brew install tig\n\n\n\nリッチな top コマンド．CPU 利用率を目視で計測するために用いている．\n% brew install htop\n\n\n\nCodex ユーザは入れてもよいかもしれない．\n% brew install ripgrep\n\n\n\nこの資料をローカルで見たい場合には必要\nSee Welcome to Quarto to learn more."
  },
  {
    "objectID": "slides/slide.html#overview",
    "href": "slides/slide.html#overview",
    "title": "Introduction to Coding Agents",
    "section": "Overview",
    "text": "Overview\n\nSelf-introduction\nIntroduction to AI-powered software\nIntroduction to AI agents\nHands-on exercises with several topics"
  },
  {
    "objectID": "slides/slide.html#self-introduction",
    "href": "slides/slide.html#self-introduction",
    "title": "Introduction to Coding Agents",
    "section": "Self-introduction",
    "text": "Self-introduction\n\nFreelance software engineer. Collaborative development of scientific computing with university faculty\nGitHub: terasakisatoshi\nOrganization: AtelierArith"
  },
  {
    "objectID": "slides/slide.html#recent-work-organizing-sparseir-ecosystem",
    "href": "slides/slide.html#recent-work-organizing-sparseir-ecosystem",
    "title": "Introduction to Coding Agents",
    "section": "Recent work: Organizing SparseIR ecosystem",
    "text": "Recent work: Organizing SparseIR ecosystem\n\nCollaborative development with Hiroshi Shinaoka and Hitoshi Mori\n\nPorting SparseIR.jl v1.0 to C++: libsparseir (C++)\nPorting libsparseir to Rust: sparse-ir-rs\nSparseIR.jl v2.0 (Julia interface for sparse-ir-rs)\nsparse-ir v2.0 (Python interface for sparse-ir-rs)"
  },
  {
    "objectID": "slides/slide.html#recent-work-tensor4all",
    "href": "slides/slide.html#recent-work-tensor4all",
    "title": "Introduction to Coding Agents",
    "section": "Recent work: tensor4all",
    "text": "Recent work: tensor4all\n\ntensor4all: A Rust implementation of tensor networks\n\nPorting Strided.jl to Rust strided-rs\nstrided-rs-benchmark-suite"
  },
  {
    "objectID": "slides/slide.html#recent-work-mvmc",
    "href": "slides/slide.html#recent-work-mvmc",
    "title": "Introduction to Coding Agents",
    "section": "Recent work: mVMC",
    "text": "Recent work: mVMC\n\nTakahiro Misawa et al.\n\nPorting C project mVMC to Julia (WIP)\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis project is still work in progress. It will be released in the future."
  },
  {
    "objectID": "slides/slide.html#recent-work-subsetjuliavm",
    "href": "slides/slide.html#recent-work-subsetjuliavm",
    "title": "Introduction to Coding Agents",
    "section": "Recent work: SubsetJuliaVM",
    "text": "Recent work: SubsetJuliaVM\nLet’s run Julia on iPad and iPhone"
  },
  {
    "objectID": "slides/slide.html#recent-work-better-pluto-client",
    "href": "slides/slide.html#recent-work-better-pluto-client",
    "title": "Introduction to Coding Agents",
    "section": "Recent work: better-pluto-client",
    "text": "Recent work: better-pluto-client\nWe can view pluto notebook on VS Code."
  },
  {
    "objectID": "slides/slide.html#recent-work-rustcall.jl",
    "href": "slides/slide.html#recent-work-rustcall.jl",
    "title": "Introduction to Coding Agents",
    "section": "Recent work: RustCall.jl",
    "text": "Recent work: RustCall.jl\nA package that allows calling Rust from Julia.\nusing RustCall\n\nrust\"\"\"\n#[julia]\nfn add(a: i32, b: i32) -&gt; i32 {\n    a + b\n}\n\"\"\"\n\n# Call directly - wrapper is auto-generated\nadd(10, 20)  # =&gt; 30"
  },
  {
    "objectID": "slides/slide.html#actually",
    "href": "slides/slide.html#actually",
    "title": "Introduction to Coding Agents",
    "section": "Actually",
    "text": "Actually\nOver 90% of the software introduced so far was generated using AI. This is a fact.\nHumans give instructions in natural language for what they want to build, and AI agents generate source code and execute commands.\nThis approach to development using AI is called AI-driven development."
  },
  {
    "objectID": "slides/slide.html#in-reality",
    "href": "slides/slide.html#in-reality",
    "title": "Introduction to Coding Agents",
    "section": "In reality",
    "text": "In reality\n\n\nGit is not used. No version control\nNo documentation, or it’s outdated\nNo unit tests\nCode doesn’t compile\nRuntime errors occur (segmentation faults, etc.)\nDataset URLs point to a researcher’s personal C: drive (hardcoded variables)"
  },
  {
    "objectID": "slides/slide.html#humans-and-machines",
    "href": "slides/slide.html#humans-and-machines",
    "title": "Introduction to Coding Agents",
    "section": "Humans and machines",
    "text": "Humans and machines\n\nHumans can “create” but they “get tired,” “get bored,” and “get stuck”\n\nComing up with new ideas like in research activities\nOverusing git commit -m \"update\" and git commit -m \"fix\"\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSticking to a specific programming language\n\nCreates environments where adopting modern practices like package managers is difficult"
  },
  {
    "objectID": "slides/slide.html#humans-and-machines-1",
    "href": "slides/slide.html#humans-and-machines-1",
    "title": "Introduction to Coding Agents",
    "section": "Humans and machines",
    "text": "Humans and machines\n\nHumans can “create” but they “get tired,” “get bored,” and “get stuck”\n\n\nDear scientists, when writing new numerical computing software, use Julia or Rust for scientific computing. They have modern package management systems that enable collaborative development.\n\n\nJulia provides fast execution while remaining a high-level language. You should use it if you typically write Fortran. However, type-unstable code, frequent GC (garbage collection), and memory allocation can prevent optimal performance. Tensor network packages that handle multidimensional arrays often encounter this issue.\n\n\nRust is a fast static language. Those who write C/C++ should consider switching. Rust has a learning curve when written manually, but AI code generation dramatically improves the development experience.\n\n\nThe tensor4all-rs ecosystem for tensor networks aims to be an excellent example of adopting Rust for scientific computing."
  },
  {
    "objectID": "slides/slide.html#humans-and-machines-2",
    "href": "slides/slide.html#humans-and-machines-2",
    "title": "Introduction to Coding Agents",
    "section": "Humans and machines",
    "text": "Humans and machines\n\nMachines “don’t get bored,” “don’t get tired,” and “models improve”\n\nGenerate appropriate commit and pull request summaries from code diffs"
  },
  {
    "objectID": "slides/slide.html#humans-and-machines-3",
    "href": "slides/slide.html#humans-and-machines-3",
    "title": "Introduction to Coding Agents",
    "section": "Humans and machines",
    "text": "Humans and machines\n\nMachines “don’t get bored,” “don’t get tired,” and “models improve”\nWork anytime\n\nCan use various languages. Good at porting:\nJulia -&gt; C++, C++ -&gt; Rust, C -&gt; Julia\nTypeScript, Swift, Flutter/Dart\n\nCan adapt to requests. Migration to modern languages is possible\nRequires appropriate instructions from humans"
  },
  {
    "objectID": "slides/slide.html#the-rise-of-coding-agents",
    "href": "slides/slide.html#the-rise-of-coding-agents",
    "title": "Introduction to Coding Agents",
    "section": "The rise of coding agents",
    "text": "The rise of coding agents\nWith advances in AI and generative AI, coding agents and AI agents can now take the following actions to achieve goals when given human instructions:"
  },
  {
    "objectID": "slides/slide.html#are-humans-unnecessary-no",
    "href": "slides/slide.html#are-humans-unnecessary-no",
    "title": "Introduction to Coding Agents",
    "section": "Are humans unnecessary? (No)",
    "text": "Are humans unnecessary? (No)\n\nLLMs have much knowledge but may not have cutting-edge knowledge like researchers. What to implement or not depends on human judgment.\nSoftware engineers are freed from coding time but need higher-level skills: choosing which technologies to use when, designing architecture for high-quality software, and making decisions. Minimal domain knowledge to discuss with researchers is also required."
  },
  {
    "objectID": "slides/slide.html#are-humans-unnecessary-no-1",
    "href": "slides/slide.html#are-humans-unnecessary-no-1",
    "title": "Introduction to Coding Agents",
    "section": "Are humans unnecessary? (No)",
    "text": "Are humans unnecessary? (No)\n\nAI can slack off when writing code\n\nSatisfied with writing only placeholders\nImplements only special cases when a general implementation is needed\n\nNot always best-practice implementation\n\nIn Julia: doesn’t use multiple dispatch, overuses export\nIn Rust: overuses .clone(), degrading performance\n\nMinimal knowledge of how to run code, coding, and programming languages is necessary."
  },
  {
    "objectID": "slides/slide.html#are-software-engineers-unnecessary",
    "href": "slides/slide.html#are-software-engineers-unnecessary",
    "title": "Introduction to Coding Agents",
    "section": "Are software engineers unnecessary?",
    "text": "Are software engineers unnecessary?\n\nAn extreme claim: AI development could make researchers unnecessary\nAI adoption frees us from local concerns like language learning cost, fine grammar, and coding style\nWe can focus on architecture-level design and global discussions: “How to design software with good user experience,” “Which technologies and languages to choose for each situation,” “How to maintain high-quality software”\nWhat to implement or not is largely determined by human judgment\nBottleneck investigation with visual profilers is difficult to fully automate with AI. Such workflows still exist\n\nOptimization at millisecond, microsecond, nanosecond levels relies on human intuition. Demand remains"
  },
  {
    "objectID": "slides/slide.html#are-software-engineers-unnecessary-1",
    "href": "slides/slide.html#are-software-engineers-unnecessary-1",
    "title": "Introduction to Coding Agents",
    "section": "Are software engineers unnecessary?",
    "text": "Are software engineers unnecessary?\n\nGaining domain knowledge is important—physics knowledge sufficient to communicate with physicists\nRust code can run on the web via WebAssembly. Work will emerge for publishing and maintaining numerical computing demos on the web"
  },
  {
    "objectID": "slides/slide.html#are-software-engineers-unnecessary-2",
    "href": "slides/slide.html#are-software-engineers-unnecessary-2",
    "title": "Introduction to Coding Agents",
    "section": "Are software engineers unnecessary?",
    "text": "Are software engineers unnecessary?\n\nResearchers will get busier. They can do what they couldn’t before but wanted to. Work will increase accordingly\nResearchers won’t be idle. One researcher subscribed to Claude Code MAX $200 and got dizzy from full AI usage\n\nI recommended downgrading to the $100 plan. Sounds like a joke but it’s true"
  },
  {
    "objectID": "slides/slide.html#are-software-engineers-unnecessary-3",
    "href": "slides/slide.html#are-software-engineers-unnecessary-3",
    "title": "Introduction to Coding Agents",
    "section": "Are software engineers unnecessary?",
    "text": "Are software engineers unnecessary?\n\nJobs disappear when a certain passion disappears."
  },
  {
    "objectID": "slides/slide.html#demo",
    "href": "slides/slide.html#demo",
    "title": "Introduction to Coding Agents",
    "section": "Demo",
    "text": "Demo\nIntroducing coding with Cursor.\nAlternatives: Antigravity, Claude Code, Codex."
  },
  {
    "objectID": "slides/slide.html#which-tool-should-you-use",
    "href": "slides/slide.html#which-tool-should-you-use",
    "title": "Introduction to Coding Agents",
    "section": "Which tool should you use?",
    "text": "Which tool should you use?\n\nThere is no single answer since AI agents are constantly evolving\nDepends on which accounts you have\n\nIf you have ChatGPT: try Codex, GPT-5.3\nIf you have Claude: try Claude Code: Opus-4.6\n\nWant to use for free\n\nUse Google’s Antigravity\n\nAll services have usage limits. It all comes down to budget"
  },
  {
    "objectID": "slides/slide.html#which-tool-should-you-use-as-for-me",
    "href": "slides/slide.html#which-tool-should-you-use-as-for-me",
    "title": "Introduction to Coding Agents",
    "section": "Which tool should you use? (as for me)",
    "text": "Which tool should you use? (as for me)\n\nClaude Code MAX $200/$100: Opus-4.6\nChatGPT Plus plan: Codex: GPT-5.3\nCursor Pro: Daily editor with Composer 1.5"
  },
  {
    "objectID": "slides/slide.html#required-cli-tools",
    "href": "slides/slide.html#required-cli-tools",
    "title": "Introduction to Coding Agents",
    "section": "Required CLI tools",
    "text": "Required CLI tools\n\ngit, gh: Operate Git/GitHub\nuv: Python package manager\nnpm, node: Installing coding agents\njuliaup, julia: Required to run Julia code\nrustup, rustc, cargo: Required to build and run Rust code\n\nOptional:\n\ndocker\ndevcontainer\nrg\ntree\nhtop\nquarto"
  },
  {
    "objectID": "slides/slide.html#installation",
    "href": "slides/slide.html#installation",
    "title": "Introduction to Coding Agents",
    "section": "Installation",
    "text": "Installation\nTODO: See 01-preparation.qmd"
  },
  {
    "objectID": "slides/slide.html#installation-1",
    "href": "slides/slide.html#installation-1",
    "title": "Introduction to Coding Agents",
    "section": "Installation",
    "text": "Installation\nGo to the link below:\n\nhttps://cursor.com/download\nVS Code users can migrate extensions"
  },
  {
    "objectID": "slides/slide.html#math-quiz",
    "href": "slides/slide.html#math-quiz",
    "title": "Introduction to Coding Agents",
    "section": "Math Quiz",
    "text": "Math Quiz\nGiven two positive integers \\(a\\) and \\(b\\), what is the probability that their greatest common divisor \\(\\gcd(a,b)\\) equals 1?\n\nThe answer is\n\\[\n\\frac{1}{\\zeta(2)} = \\frac{6}{\\pi^2} \\approx 0.6079271018540267\n\\]\nwhere \\(\\zeta\\) is the Riemann zeta function.\n\\[\n\\zeta(s) = \\sum_{n=1}^{\\infty} \\frac{1}{n^s}= \\prod_{p: \\mathrm{primes} } \\left(\\frac{1}{1 - p^{-s}}  \\right) \\mathrm{}\n\\]\nThe second equality is due to the Euler product."
  },
  {
    "objectID": "slides/slide.html#proof",
    "href": "slides/slide.html#proof",
    "title": "Introduction to Coding Agents",
    "section": "Proof",
    "text": "Proof\n\\[\n\\begin{aligned}\n\\mathrm{Prob}(\\gcd(a, b) = 1)\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - \\mathrm{Prob}(p | a \\textrm{ and } p | b)\\right) \\\\\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - \\mathrm{Prob}(p | a)\\mathrm{Prob}(p | b)\\right) \\\\\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - \\frac{1}{p}\\cdot\\frac{1}{p}\\right) \\\\\n&= \\prod_{p: \\mathrm{primes} } \\left( 1 - p^{-2}\\right) \\\\\n&= \\left(\\prod_{p: \\mathrm{primes} } \\left(\\frac{1}{1 - p^{-2}}  \\right)\\right)^{-1} \\\\\n&=\\left(\\zeta(2)\\right)^{-1} \\\\\n&= \\frac{1}{\\zeta(2)} = \\frac{6}{\\pi^2}\n\\end{aligned}\n\\]"
  },
  {
    "objectID": "slides/slide.html#application-js-implementation",
    "href": "slides/slide.html#application-js-implementation",
    "title": "Introduction to Coding Agents",
    "section": "Application (JS implementation)",
    "text": "Application (JS implementation)\nFrom the proof above we obtain:\n\\[\n\\pi = \\sqrt{\\frac{6}{\\mathrm{Prob}(\\gcd(a, b)=1)}}\n\\]\nLet’s verify with numerical computation\n// Function to approximate pi\n// using probability that two numbers are coprime\nfunction calcPi(N) {\n    let cnt = 0;    // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for (let a = 1; a &lt;= N; a++) {\n        for (let b = 1; b &lt;= N; b++) {\n            // Check if a and b are coprime\n            if (mygcd(a, b) === 1) {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt / (N * N);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return Math.sqrt(6 / prob);\n}"
  },
  {
    "objectID": "slides/slide.html#application-js-implementation-1",
    "href": "slides/slide.html#application-js-implementation-1",
    "title": "Introduction to Coding Agents",
    "section": "Application (JS implementation)",
    "text": "Application (JS implementation)\nLet’s calculate the \\(\\pi \\approx 3.14...\\) from GCD function:\n// approx_pi_gcd.js\n\n// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nfunction mygcd(a, b) {\n    // Loop until the remainder is zero\n    while (b !== 0) {\n        let tmp = b;    // Store the value of b temporarily\n        b = a % b;      // Update b to the remainder of a divided by b\n        a = tmp;        // Set a to the previous value of b\n    }\n    return a;           // When b is zero, a is the GCD\n}\n\n// Function to approximate pi using probability that two numbers are coprime\nfunction calcPi(N) {\n    let cnt = 0;    // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for (let a = 1; a &lt;= N; a++) {\n        for (let b = 1; b &lt;= N; b++) {\n            // Check if a and b are coprime\n            if (mygcd(a, b) === 1) {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt / (N * N);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return Math.sqrt(6 / prob);\n}\n\n// Main function to run the pi approximation\nfunction main() {\n    let N = 10000;            // Number limit for coprimality checking\n    let pi = calcPi(N);       // Approximate pi\n    console.log(`N: ${N}`);   // Output N\n    console.log(`pi: ${pi}`); // Output approximation of pi\n}\n\nmain(); // Call the main function\nResult\n$ node approx_pi_gcd.js\ncalcPi: 2.175s\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide.html#exercise",
    "href": "slides/slide.html#exercise",
    "title": "Introduction to Coding Agents",
    "section": "Exercise",
    "text": "Exercise\nPort the JavaScript code above to Julia and Rust. Measure the execution time when N=10000.\nHint\nUse the following prompts:\n\nPort approx_pi_gcd.js to Julia and save the result as approx_pi_gcd.jl\n\n\nPort approx_pi_gcd.rs to Rust and save the result as approx_pi_gcd.rs"
  },
  {
    "objectID": "slides/slide.html#answer",
    "href": "slides/slide.html#answer",
    "title": "Introduction to Coding Agents",
    "section": "Answer",
    "text": "Answer"
  },
  {
    "objectID": "slides/slide.html#answerjulia",
    "href": "slides/slide.html#answerjulia",
    "title": "Introduction to Coding Agents",
    "section": "Answer(Julia)",
    "text": "Answer(Julia)\n# Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nfunction mygcd(a, b)\n    # Loop until the remainder is zero\n    while b != 0\n        tmp = b    # Store the value of b temporarily\n        b = a % b  # Update b to the remainder of a divided by b\n        a = tmp    # Set a to the previous value of b\n    end\n    return a       # When b is zero, a is the GCD\nend\n\n# Function to approximate pi using probability that two numbers are coprime\nfunction calcPi(N)\n    cnt = 0    # Counter for coprime pairs\n    # Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1:N\n        for b in 1:N\n            # Check if a and b are coprime\n            if mygcd(a, b) == 1\n                cnt += 1  # Increment counter if coprime\n            end\n        end\n    end\n    # Probability that two numbers are coprime\n    prob = cnt / (N * N)\n    # Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return sqrt(6 / prob)\nend\n\n# Main function to run the pi approximation\nfunction main()\n    N = 10000            # Number limit for coprimality checking\n    approx_pi = @time calcPi(N) # Approximate pi and time it\n    println(\"N: $(N)\")   # Output N\n    println(\"pi: $(approx_pi)\") # Output approximation of pi\nend\n\nmain() # Call the main function\nResult\n$ julia approx_pi_gcd.jl\n  1.865392 seconds\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide.html#answer-rust",
    "href": "slides/slide.html#answer-rust",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Rust)",
    "text": "Answer (Rust)\n// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nfn mygcd(a: u64, b: u64) -&gt; u64 {\n    let mut a = a;\n    let mut b = b;\n    // Loop until the remainder is zero\n    while b != 0 {\n        let tmp = b;    // Store the value of b temporarily\n        b = a % b;      // Update b to the remainder of a divided by b\n        a = tmp;        // Set a to the previous value of b\n    }\n    a                   // When b is zero, a is the GCD\n}\n\n// Function to approximate pi using probability that two numbers are coprime\nfn calc_pi(n: u64) -&gt; f64 {\n    let mut cnt = 0u64; // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1..=n {\n        for b in 1..=n {\n            // Check if a and b are coprime\n            if mygcd(a, b) == 1 {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt as f64 / (n as f64 * n as f64);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    (6.0 / prob).sqrt()\n}\n\n// Main function to run the pi approximation\nfn main() {\n    let n = 10000u64;   // Number limit for coprimality checking\n    let start = std::time::Instant::now();\n    let pi = calc_pi(n); // Approximate pi\n    let duration = start.elapsed();\n    println!(\"calcPi: {:?}\", duration);\n    println!(\"N: {}\", n);   // Output N\n    println!(\"pi: {}\", pi); // Output approximation of pi\n}\nResult\n$ rustc -C opt-level=3 approx_pi_gcd.rs && ./approx_pi_gcd\ncalcPi: 1.754083333s\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide.html#answer-c",
    "href": "slides/slide.html#answer-c",
    "title": "Introduction to Coding Agents",
    "section": "Answer (C)",
    "text": "Answer (C)\n#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;time.h&gt;\n\n// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm\nint mygcd(int a, int b) {\n    // Loop until the remainder is zero\n    while (b != 0) {\n        int tmp = b;    // Store the value of b temporarily\n        b = a % b;      // Update b to the remainder of a divided by b\n        a = tmp;        // Set a to the previous value of b\n    }\n    return a;           // When b is zero, a is the GCD\n}\n\n// Function to approximate pi using probability that two numbers are coprime\ndouble calcPi(int N) {\n    int cnt = 0;    // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for (int a = 1; a &lt;= N; a++) {\n        for (int b = 1; b &lt;= N; b++) {\n            // Check if a and b are coprime\n            if (mygcd(a, b) == 1) {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    double prob = (double)cnt / (N * N);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return sqrt(6.0 / prob);\n}\n\n// Main function to run the pi approximation\nint main() {\n    int N = 10000;            // Number limit for coprimality checking\n    clock_t start = clock();\n    double pi = calcPi(N);    // Approximate pi\n    clock_t end = clock();\n    double cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;\n\n    printf(\"calcPi: %f seconds\\n\", cpu_time_used);\n    printf(\"N: %d\\n\", N);     // Output N\n    printf(\"pi: %f\\n\", pi);   // Output approximation of pi\n\n    return 0;\n}\nResult\n$ gcc -O3 approx_pi_gcd.c && ./a.out\ncalcPi: 1.753796 seconds\nN: 10000\npi: 3.141534"
  },
  {
    "objectID": "slides/slide.html#julia-can-execute-this-much-faster.",
    "href": "slides/slide.html#julia-can-execute-this-much-faster.",
    "title": "Introduction to Coding Agents",
    "section": "Julia can execute this much faster.",
    "text": "Julia can execute this much faster.\n# Function to approximate pi using probability that two numbers are coprime\nfunction calcPi(N)\n    cnt = 0    # Counter for coprime pairs\n    # Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1:N\n        for b in 1:N\n            # Check if a and b are coprime\n            if gcd(a, b) == 1\n                cnt += 1  # Increment counter if coprime\n            end\n        end\n    end\n    # Probability that two numbers are coprime\n    prob = cnt / (N * N)\n    # Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    return sqrt(6 / prob)\nend\n\n# Main function to run the pi approximation\nfunction main()\n    N = 10000            # Number limit for coprimality checking\n    approx_pi = @time calcPi(N) # Approximate pi and time it\n    println(\"N: $(N)\")   # Output N\n    println(\"pi: $(approx_pi)\") # Output approximation of pi\nend\n\nmain() # Call the main function\nResult\njulia approx_pi_gcd.jl\n  1.454210 seconds\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide.html#julia-got-faster",
    "href": "slides/slide.html#julia-got-faster",
    "title": "Introduction to Coding Agents",
    "section": "Julia got faster?!",
    "text": "Julia got faster?!\nWhy did it go from 1.865392 seconds to 1.454210 seconds?\nBecause Julia’s gcd function uses a different algorithm than the Euclidean algorithm."
  },
  {
    "objectID": "slides/slide.html#exercise-1",
    "href": "slides/slide.html#exercise-1",
    "title": "Introduction to Coding Agents",
    "section": "Exercise",
    "text": "Exercise\n\nClone the Julia repository and have the coding agent explain how the gcd function works\nHave it answer what algorithm is used\nHave it port Julia’s gcd implementation to replace mygcd in the code we ported from JavaScript to Rust\n\nHint\n\ngit clone --depth 1 &lt;url&gt; enables fast cloning (shallow clone). Use the following prompt:\n\n\nRead the Julia code and answer how the gcd function is defined. Read @julia\n\n\nPort these gcd functions to Rust"
  },
  {
    "objectID": "slides/slide.html#answer-1",
    "href": "slides/slide.html#answer-1",
    "title": "Introduction to Coding Agents",
    "section": "Answer",
    "text": "Answer\n\n\n\n\nIndeed, the code is as follows:\n# binary GCD (aka Stein's) algorithm\n# about 1.7x (2.1x) faster for random Int64s (Int128s)\n# Unfortunately, we need to manually annotate this as `@assume_effects :terminates_locally` to work around #41694.\n# Since this is used in the Rational constructor, constant folding is something we do care about here.\n@assume_effects :terminates_locally function _gcd(ain::T, bin::T) where T&lt;:BitInteger\n    zb = trailing_zeros(bin)\n    za = trailing_zeros(ain)\n    a = abs(ain)\n    b = abs(bin &gt;&gt; zb)\n    k = min(za, zb)\n    while a != 0\n        a &gt;&gt;= za\n        absd, diff = absdiff(a, b)\n        za = trailing_zeros(diff)\n        b = min(a, b)\n        a = absd\n    end\n    r = b &lt;&lt; k\n    return r % T\nend"
  },
  {
    "objectID": "slides/slide.html#answer-cursor-with-auto-mode",
    "href": "slides/slide.html#answer-cursor-with-auto-mode",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Cursor with Auto-mode)",
    "text": "Answer (Cursor with Auto-mode)"
  },
  {
    "objectID": "slides/slide.html#answer-rust-implementation",
    "href": "slides/slide.html#answer-rust-implementation",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Rust implementation)",
    "text": "Answer (Rust implementation)\n// Port of Julia's gcd functions from base/intfuncs.jl\n// Greatest common divisor implementations using Euclidean and Binary GCD algorithms\n\nuse std::ops::{Rem, Shr, Shl, Sub, BitAnd};\n\n/// Greatest common (positive) divisor (or zero if all arguments are zero).\n///\n/// This is the general implementation for all integer types using the Euclidean algorithm.\npub fn gcd&lt;T&gt;(mut a: T, mut b: T) -&gt; T\nwhere\n    T: Copy + PartialEq + Rem&lt;Output = T&gt; + From&lt;u8&gt; + Default,\n{\n    let zero = T::from(0u8);\n    while b != zero {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    checked_abs(a)\n}\n\n/// Greatest common divisor for fixed-width integer types using Binary GCD (Stein's) algorithm.\n///\n/// This is about 1.7x (2.1x) faster for random Int64s (Int128s) compared to Euclidean algorithm.\npub fn gcd_bitinteger&lt;T&gt;(a: T, b: T) -&gt; T\nwhere\n    T: Copy\n        + PartialEq\n        + PartialOrd\n        + Shr&lt;usize, Output = T&gt;\n        + Shl&lt;usize, Output = T&gt;\n        + BitAnd&lt;Output = T&gt;\n        + Sub&lt;Output = T&gt;\n        + From&lt;u8&gt;\n        + Default,\n{\n    let zero = T::from(0u8);\n\n    if a == zero {\n        return checked_abs(b);\n    }\n    if b == zero {\n        return checked_abs(a);\n    }\n\n    // Handle typemin case for signed types\n    // In Rust, we check for the minimum value differently\n    // For now, we'll proceed with the algorithm\n\n    _gcd(a, b)\n}\n\n/// Binary GCD (aka Stein's) algorithm implementation.\n///\n/// This is the core algorithm that's faster for fixed-width integers.\nfn _gcd&lt;T&gt;(ain: T, bin: T) -&gt; T\nwhere\n    T: Copy\n        + PartialEq\n        + PartialOrd\n        + Shr&lt;usize, Output = T&gt;\n        + Shl&lt;usize, Output = T&gt;\n        + BitAnd&lt;Output = T&gt;\n        + Sub&lt;Output = T&gt;\n        + From&lt;u8&gt;\n        + Default,\n{\n    let zero = T::from(0u8);\n\n    let zb = trailing_zeros(bin);\n    let mut za = trailing_zeros(ain);\n    let mut a = abs(ain);\n    let mut b = abs(bin &gt;&gt; zb);\n    let k = if za &lt; zb { za } else { zb };\n\n    while a != zero {\n        a = a &gt;&gt; za;\n        let (absd, diff) = absdiff(a, b);\n        za = trailing_zeros(diff);\n        b = if a &lt; b { a } else { b };\n        a = absd;\n    }\n\n    let r = b &lt;&lt; k;\n    r\n}\n\n/// Compute absolute difference between two values.\n/// Returns (absolute difference, signed difference).\nfn absdiff&lt;T&gt;(x: T, y: T) -&gt; (T, T)\nwhere\n    T: Copy + PartialOrd + Sub&lt;Output = T&gt; + From&lt;u8&gt;,\n{\n    if x &gt;= y {\n        let d = x - y;\n        (d, d)\n    } else {\n        let d = y - x;\n        (d, d)\n    }\n}\n\n/// Compute the number of trailing zeros in the binary representation.\n///\n/// For unsigned types, this counts trailing zeros.\n/// For signed types, we convert to unsigned first.\nfn trailing_zeros&lt;T&gt;(x: T) -&gt; usize\nwhere\n    T: Copy,\n{\n    // This is a simplified version. In practice, you'd use the built-in\n    // trailing_zeros method for each integer type.\n    // For a generic implementation, we'd need trait bounds that include\n    // the actual integer traits.\n\n    // For now, we'll use a basic implementation\n    // In real code, you'd specialize for each integer type\n    if let Some(val) = try_to_u64(x) {\n        val.trailing_zeros() as usize\n    } else {\n        // Fallback: count manually\n        count_trailing_zeros_fallback(x)\n    }\n}\n\n/// Try to convert a value to u64 for trailing_zeros calculation.\nfn try_to_u64&lt;T&gt;(_x: T) -&gt; Option&lt;u64&gt; {\n    None // Generic implementation - would need specialization\n}\n\n/// Fallback trailing zeros counting.\nfn count_trailing_zeros_fallback&lt;T&gt;(_x: T) -&gt; usize {\n    0 // Placeholder - would need proper implementation\n}\n\n/// Compute absolute value with overflow checking.\nfn checked_abs&lt;T&gt;(x: T) -&gt; T\nwhere\n    T: Copy,\n{\n    // For unsigned types, abs is a no-op\n    // For signed types, we'd use checked_abs\n    // This is a simplified version\n    abs(x)\n}\n\n/// Compute absolute value.\nfn abs&lt;T&gt;(x: T) -&gt; T\nwhere\n    T: Copy,\n{\n    // For unsigned types, this is a no-op\n    // For signed types, we'd need to handle negation\n    // This is a simplified generic version\n    x\n}\n\n// Specialized implementations for specific integer types\n\n/// GCD for u8\npub fn gcd_u8(a: u8, b: u8) -&gt; u8 {\n    gcd_bitinteger_u8(a, b)\n}\n\n/// Binary GCD for u8 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u8(ain: u8, bin: u8) -&gt; u8 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u16\npub fn gcd_u16(a: u16, b: u16) -&gt; u16 {\n    gcd_bitinteger_u16(a, b)\n}\n\n/// Binary GCD for u16 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u16(ain: u16, bin: u16) -&gt; u16 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u32\npub fn gcd_u32(a: u32, b: u32) -&gt; u32 {\n    gcd_bitinteger_u32(a, b)\n}\n\n/// Binary GCD for u32 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u32(ain: u32, bin: u32) -&gt; u32 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u64\npub fn gcd_u64(a: u64, b: u64) -&gt; u64 {\n    gcd_bitinteger_u64(a, b)\n}\n\n/// Binary GCD for u64 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u64(ain: u64, bin: u64) -&gt; u64 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for u128\npub fn gcd_u128(a: u128, b: u128) -&gt; u128 {\n    gcd_bitinteger_u128(a, b)\n}\n\n/// Binary GCD for u128 (Stein's algorithm matching Julia's implementation)\npub fn gcd_bitinteger_u128(ain: u128, bin: u128) -&gt; u128 {\n    if ain == 0 {\n        return bin;\n    }\n    if bin == 0 {\n        return ain;\n    }\n\n    let zb = bin.trailing_zeros() as usize;\n    let mut za = ain.trailing_zeros() as usize;\n    let mut a = ain;\n    let mut b = bin &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    b &lt;&lt; k\n}\n\n/// GCD for i8\npub fn gcd_i8(a: i8, b: i8) -&gt; i8 {\n    gcd_bitinteger_i8(a, b)\n}\n\n/// Binary GCD for i8 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i8(ain: i8, bin: i8) -&gt; i8 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    // Handle typemin case\n    if ain == i8::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i8\n}\n\n/// GCD for i16\npub fn gcd_i16(a: i16, b: i16) -&gt; i16 {\n    gcd_bitinteger_i16(a, b)\n}\n\n/// Binary GCD for i16 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i16(ain: i16, bin: i16) -&gt; i16 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i16::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i16\n}\n\n/// GCD for i32\npub fn gcd_i32(a: i32, b: i32) -&gt; i32 {\n    gcd_bitinteger_i32(a, b)\n}\n\n/// Binary GCD for i32 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i32(ain: i32, bin: i32) -&gt; i32 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i32::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i32\n}\n\n/// GCD for i64\npub fn gcd_i64(a: i64, b: i64) -&gt; i64 {\n    gcd_bitinteger_i64(a, b)\n}\n\n/// Binary GCD for i64 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i64(ain: i64, bin: i64) -&gt; i64 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i64::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i64\n}\n\n/// GCD for i128\npub fn gcd_i128(a: i128, b: i128) -&gt; i128 {\n    gcd_bitinteger_i128(a, b)\n}\n\n/// Binary GCD for i128 with signed integer handling (matching Julia's algorithm)\npub fn gcd_bitinteger_i128(ain: i128, bin: i128) -&gt; i128 {\n    if ain == 0 {\n        return bin.abs();\n    }\n    if bin == 0 {\n        return ain.abs();\n    }\n\n    if ain == i128::MIN && ain == bin {\n        panic!(\"gcd({}, {}) overflows\", ain, bin);\n    }\n\n    let zb = bin.unsigned_abs().trailing_zeros() as usize;\n    let mut za = ain.unsigned_abs().trailing_zeros() as usize;\n    let mut a = ain.unsigned_abs();\n    let mut b = bin.unsigned_abs() &gt;&gt; zb;\n    let k = za.min(zb);\n\n    while a != 0 {\n        a &gt;&gt;= za;\n        let absd = if a &gt;= b { a - b } else { b - a };\n        let diff = absd;\n        za = diff.trailing_zeros() as usize;\n        b = a.min(b);\n        a = absd;\n    }\n\n    (b &lt;&lt; k) as i128\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_gcd_u64() {\n        assert_eq!(gcd_u64(6, 9), 3);\n        assert_eq!(gcd_u64(6, 0), 6);\n        assert_eq!(gcd_u64(0, 0), 0);\n        assert_eq!(gcd_u64(48, 18), 6);\n        assert_eq!(gcd_u64(17, 13), 1);\n    }\n\n    #[test]\n    fn test_gcd_i64() {\n        assert_eq!(gcd_i64(6, 9), 3);\n        assert_eq!(gcd_i64(6, -9), 3);\n        assert_eq!(gcd_i64(-6, 9), 3);\n        assert_eq!(gcd_i64(-6, -9), 3);\n        assert_eq!(gcd_i64(6, 0), 6);\n        assert_eq!(gcd_i64(0, 0), 0);\n    }\n\n    #[test]\n    fn test_gcd_u32() {\n        assert_eq!(gcd_u32(48, 18), 6);\n        assert_eq!(gcd_u32(100, 25), 25);\n    }\n\n    #[test]\n    fn test_gcd_i32() {\n        assert_eq!(gcd_i32(48, -18), 6);\n        assert_eq!(gcd_i32(-100, 25), 25);\n    }\n}\n\n// Function to approximate pi using probability that two numbers are coprime\nfn calc_pi(n: u64) -&gt; f64 {\n    let mut cnt = 0u64; // Counter for coprime pairs\n    // Loop through all pairs (a, b) where 1 &lt;= a, b &lt;= N\n    for a in 1..=n {\n        for b in 1..=n {\n            // Check if a and b are coprime using the fast binary GCD algorithm\n            if gcd::gcd_u64(a, b) == 1 {\n                cnt += 1;  // Increment counter if coprime\n            }\n        }\n    }\n    // Probability that two numbers are coprime\n    let prob = cnt as f64 / (n as f64 * n as f64);\n    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)\n    (6.0 / prob).sqrt()\n}\n\n// Main function to run the pi approximation\nfn main() {\n    let n = 10000u64;   // Number limit for coprimality checking\n    let start = std::time::Instant::now();\n    let pi = calc_pi(n); // Approximate pi\n    let duration = start.elapsed();\n    println!(\"calcPi: {:?}\", duration);\n    println!(\"N: {}\", n);   // Output N\n    println!(\"pi: {}\", pi); // Output approximation of pi\n}\nResult\nrustc -C opt-level=3 gcd.rs && ./gcd\ncalcPi: 1.2510425s\nN: 10000\npi: 3.141534239016629"
  },
  {
    "objectID": "slides/slide.html#the-binary-gcd-algorithm-can-be-made-even-faster",
    "href": "slides/slide.html#the-binary-gcd-algorithm-can-be-made-even-faster",
    "title": "Introduction to Coding Agents",
    "section": "The Binary GCD Algorithm can be made even faster",
    "text": "The Binary GCD Algorithm can be made even faster\nExercise\n\nFurther optimize the Binary GCD Algorithm (1.45 -&gt; 1.07 seconds on Julia)\n\nHint\n\nImplement the Binary GCD Algorithm in Rust and measure execution time\nIf the Rust implementation is faster than Julia, compare the Rust binary with the assembly output from Julia’s @code_native macro\nFewer instructions improve execution speed; feed the comparison results back into the Julia code"
  },
  {
    "objectID": "slides/slide.html#answer-2",
    "href": "slides/slide.html#answer-2",
    "title": "Introduction to Coding Agents",
    "section": "Answer",
    "text": "Answer\n\nOpus 4.5 generated this!\n\nRust\nBenchmark:\nRun 1: 1.05132725s  pi=3.141534239016629\nRun 2: 1.0358485s  pi=3.141534239016629\nRun 3: 1.034275125s  pi=3.141534239016629\nJulia\n$ julia src/main.jl\nRunning tests...\nAll tests passed!\n\nBenchmark:\nRun 1: 1.072994208s  pi=3.141534239016629\nRun 2: 1.07328325s  pi=3.141534239016629\nRun 3: 1.072947583s  pi=3.141534239016629"
  },
  {
    "objectID": "slides/slide.html#another-example",
    "href": "slides/slide.html#another-example",
    "title": "Introduction to Coding Agents",
    "section": "Another example",
    "text": "Another example\nWhat is the expected number of random numbers (generated uniformly) such that their sum of numbers exceeds one?\nRefer this discussion on MathOverflow.\nExercise\nWrite a numerical computing program. Try it in various programming languages"
  },
  {
    "objectID": "slides/slide.html#answer-julia",
    "href": "slides/slide.html#answer-julia",
    "title": "Introduction to Coding Agents",
    "section": "Answer (Julia)",
    "text": "Answer (Julia)\nfunction count_upto_one()\n    counter = 0\n    accumulated = 0.0\n    while true\n        accumulated += rand()\n        counter += 1\n        if accumulated &gt;= 1.0\n            break\n        end\n    end\n    return counter\nend\n\nfunction main()\n    n_trial =1e8\n    total_count=0\n    for trial in 1:n_trial\n        total_count+=count_upto_one()\n    end\n    println(total_count/n_trial)\nend\n\nmain()"
  }
]