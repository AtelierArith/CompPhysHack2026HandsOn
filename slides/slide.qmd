---
title: Introduction to Coding Agents
author: SatoshiTerasaki@AtelierArith
format:
  revealjs:
    theme: "black"
    css: "../styles/style.css"
    embed-resources: true
    slide-number: true
    show-notes: separate-page
    mermaid:
      theme: default
    gfm:
    mermaid-format: png
---

## Overview

- AIエージェントの導入
- いくつかの題材をもとに使う

---

## 自己紹介

Name: Satoshi Terasaki

- ソフトウェアエンジニア．フリーランス
- 大学教員と科学計算の共同開発
  - Hiroshi Shinaoka さんとの共同開発
    - [libsparseir](https://github.com/SpM-lab/libsparseir) (C++)
    - [sparse-ir-rs](https://github.com/SpM-lab/sparse-ir-rs) (Rust)
    - [SparseIR.jl](https://github.com/SpM-lab/SparseIR.jl) v2.0 (Julia)
    - [sparse-ir](https://github.com/SpM-lab/sparse-ir) v2.0 (Python)
- ソフトウェア開発のコンサルティングを行なっている
  - Porting C project to Julia
- プロダクト開発
  - SubsetJuliaVM (iOS)

---

## ソフトウェア開発

- アイデアを考える
- 仕様を考える．
- コードを書く
  - アルゴリズムの実装
  - テストを書く
  - ドキュメントを書く
- メンテナンスをする
- 上記を繰り返す

---

## コーディングエージェントの登場

人工知能・生成 AI の発展により
コーディングエージェント・AI エージェントは人間が指示を与えたら目標を達成するために下記の行動をすることが可能になった:

- 計画を立てる(具体的にどのような実装をするかを事前に決める)
- 既存のコードの読解
- コード生成
- バグ修正
- ソフトウェアののビルド・実行をするためにコマンドを実行する
- 開発ワークフローの実行 (`git commit`, プルリクエストを作成などをができる)

---

## 人間と機械

- 人間は「創造」することができるが「疲れる」,「飽きる」,「固執する」
  - 研究活動のような新しいアイデアを出す
  - `git commit -m "update"` `git commit -m "fix"` を使いまくる
  - メンテナンスを放置する
  - 特定のプログラミング言語を使い続ける

- 機械は「飽きない」,「疲れない」,「モデルが成長」するが「人間の指示」が必要
  - コードの差分から適切なコミット・プリクエストの概要を作成
  - いつでも動作をする
  - 様々な言語を使える．移植も得意:
    - `Julia -> C++`, `C++ -> Rust`, `C -> Julia`
    - 要請に応じて変更が可能．現代的な言語にマイグレーションが可能
  - 人間からの適切な指示が必要

---

## ハンズオン

Cursor を用いたコーディングの方法を紹介する．

代替として Antigravity, Claude Code, Codex を使うこともできる．

## 必要な CLI ツール

- `git`, `gh`: Git/GitHub を操作する
- `uv`: Python package manager
- `npm`, `node`: コーディングエージェントのインストール
- `juliaup`, `julia`: Julia のコードを実行するために必要
- `rustup`, `rustc`, `cargo`: Rust のコードをビルド・実行に必要

Optional:

- `tree`
- `htop`
- `quarto`

## インストール

下記リンクに移動し

- https://cursor.com/download
- VS Code ユーザは extension をマイグレートできる．

## Math Quiz

二つのの正の整数 $a$, $b$ が与えられた時，最大公約数 $\gcd(a,b)$ が 1 になる確率はどれくらい？

## Math Quiz

二つのの正の整数 $a$, $b$ が与えられた時，最大公約数 $\gcd(a,b)$ が 1 になる確率はどれくらい？

正解は 

$$
\frac{1}{\zeta(2)} = \frac{6}{\pi^2} \approx 0.6079271018540267
$$

ここで，$\zeta$ はリーマン・ゼータ関数である．

## 証明

$$
\begin{aligned}
\mathrm{Prob}(\gcd(a, b) = 1) 
&= \prod_{p: \mathrm{primes} } \left( 1 - \mathrm{Prob}(p | a \textrm{ and } p | b)\right) \\
&= \prod_{p: \mathrm{primes} } \left( 1 - \mathrm{Prob}(p | a)\mathrm{Prob}(p | b)\right) \\
&= \prod_{p: \mathrm{primes} } \left( 1 - \frac{1}{p}\cdot\frac{1}{p}\right) \\
&= \prod_{p: \mathrm{primes} } \left( 1 - p^{-2}\right) \\
&= \left(\prod_{p: \mathrm{primes} } \left(\frac{1}{1 - p^{-2}}  \right)\right)^{-1} \\
&=\left(\zeta(2)\right)^{-1} \\
&= \frac{1}{\zeta(2)} = \frac{6}{\pi^2}
\end{aligned} 
$$

---

## Application

Let's calculate the $\pi \approx 3.14...$ from GCD function:

```js
// approx_pi_gcd.js

// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm
function mygcd(a, b) {
    // Loop until the remainder is zero
    while (b !== 0) {
        let tmp = b;    // Store the value of b temporarily
        b = a % b;      // Update b to the remainder of a divided by b
        a = tmp;        // Set a to the previous value of b
    }
    return a;           // When b is zero, a is the GCD
}

// Function to approximate pi using probability that two numbers are coprime
function calcPi(N) {
    let cnt = 0;    // Counter for coprime pairs
    // Loop through all pairs (a, b) where 1 <= a, b <= N
    for (let a = 1; a <= N; a++) {
        for (let b = 1; b <= N; b++) {
            // Check if a and b are coprime
            if (mygcd(a, b) === 1) {
                cnt += 1;  // Increment counter if coprime
            }
        }
    }
    // Probability that two numbers are coprime
    let prob = cnt / (N * N);
    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)
    return Math.sqrt(6 / prob);
}

// Main function to run the pi approximation
function main() {
    let N = 10000;            // Number limit for coprimality checking
    let pi = calcPi(N);       // Approximate pi
    console.log(`N: ${N}`);   // Output N
    console.log(`pi: ${pi}`); // Output approximation of pi
}

main(); // Call the main function
```

Result

```sh
$ node approx_pi_gcd.js
calcPi: 2.175s
N: 10000
pi: 3.141534239016629
```

---

## Exercise

先ほどの JavaScript のコードを Julia, Rust に移植してください．
`N=10000` の時の実行時間を計測してください．

Hint:

> Port `approx_pi_gcd.js` to Julia and save the result as approx_pi_gcd.jl

> Port `approx_pi_gcd.rs` to Rust and save the result as approx_pi_gcd.rs

---

## Answer(Julia)

```julia
# Function to compute the greatest common divisor (GCD) using the Euclidean algorithm
function mygcd(a, b)
    # Loop until the remainder is zero
    while b != 0
        tmp = b    # Store the value of b temporarily
        b = a % b  # Update b to the remainder of a divided by b
        a = tmp    # Set a to the previous value of b
    end
    return a       # When b is zero, a is the GCD
end

# Function to approximate pi using probability that two numbers are coprime
function calcPi(N)
    cnt = 0    # Counter for coprime pairs
    # Loop through all pairs (a, b) where 1 <= a, b <= N
    for a in 1:N
        for b in 1:N
            # Check if a and b are coprime
            if mygcd(a, b) == 1
                cnt += 1  # Increment counter if coprime
            end
        end
    end
    # Probability that two numbers are coprime
    prob = cnt / (N * N)
    # Approximate pi using the formula: pi ≈ sqrt(6 / prob)
    return sqrt(6 / prob)
end

# Main function to run the pi approximation
function main()
    N = 10000            # Number limit for coprimality checking
    approx_pi = @time calcPi(N) # Approximate pi and time it
    println("N: $(N)")   # Output N
    println("pi: $(approx_pi)") # Output approximation of pi
end

main() # Call the main function
```

Result

```julia
$ julia approx_pi_gcd.jl
  1.865392 seconds
N: 10000
pi: 3.141534239016629
```

---

## Answer (Rust)

```rust
// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm
fn mygcd(a: u64, b: u64) -> u64 {
    let mut a = a;
    let mut b = b;
    // Loop until the remainder is zero
    while b != 0 {
        let tmp = b;    // Store the value of b temporarily
        b = a % b;      // Update b to the remainder of a divided by b
        a = tmp;        // Set a to the previous value of b
    }
    a                   // When b is zero, a is the GCD
}

// Function to approximate pi using probability that two numbers are coprime
fn calc_pi(n: u64) -> f64 {
    let mut cnt = 0u64; // Counter for coprime pairs
    // Loop through all pairs (a, b) where 1 <= a, b <= N
    for a in 1..=n {
        for b in 1..=n {
            // Check if a and b are coprime
            if mygcd(a, b) == 1 {
                cnt += 1;  // Increment counter if coprime
            }
        }
    }
    // Probability that two numbers are coprime
    let prob = cnt as f64 / (n as f64 * n as f64);
    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)
    (6.0 / prob).sqrt()
}

// Main function to run the pi approximation
fn main() {
    let n = 10000u64;   // Number limit for coprimality checking
    let start = std::time::Instant::now();
    let pi = calc_pi(n); // Approximate pi
    let duration = start.elapsed();
    println!("calcPi: {:?}", duration);
    println!("N: {}", n);   // Output N
    println!("pi: {}", pi); // Output approximation of pi
}
```

Result

```sh
$ rustc -C opt-level=3 approx_pi_gcd.rs && ./approx_pi_gcd
calcPi: 1.754083333s
N: 10000
pi: 3.141534239016629
```

---

## Answer (C)

```c
#include <stdio.h>
#include <math.h>
#include <time.h>

// Function to compute the greatest common divisor (GCD) using the Euclidean algorithm
int mygcd(int a, int b) {
    // Loop until the remainder is zero
    while (b != 0) {
        int tmp = b;    // Store the value of b temporarily
        b = a % b;      // Update b to the remainder of a divided by b
        a = tmp;        // Set a to the previous value of b
    }
    return a;           // When b is zero, a is the GCD
}

// Function to approximate pi using probability that two numbers are coprime
double calcPi(int N) {
    int cnt = 0;    // Counter for coprime pairs
    // Loop through all pairs (a, b) where 1 <= a, b <= N
    for (int a = 1; a <= N; a++) {
        for (int b = 1; b <= N; b++) {
            // Check if a and b are coprime
            if (mygcd(a, b) == 1) {
                cnt += 1;  // Increment counter if coprime
            }
        }
    }
    // Probability that two numbers are coprime
    double prob = (double)cnt / (N * N);
    // Approximate pi using the formula: pi ≈ sqrt(6 / prob)
    return sqrt(6.0 / prob);
}

// Main function to run the pi approximation
int main() {
    int N = 10000;            // Number limit for coprimality checking
    clock_t start = clock();
    double pi = calcPi(N);    // Approximate pi
    clock_t end = clock();
    double cpu_time_used = ((double)(end - start)) / CLOCKS_PER_SEC;
    
    printf("calcPi: %f seconds\n", cpu_time_used);
    printf("N: %d\n", N);     // Output N
    printf("pi: %f\n", pi);   // Output approximation of pi
    
    return 0;
}
```

Result

```sh
$ gcc -O3 approx_pi_gcd.c && ./a.out         
calcPi: 1.753796 seconds
N: 10000
pi: 3.141534
```

---

## Julia はもっと高速に実行することができる．

```julia
# Function to approximate pi using probability that two numbers are coprime
function calcPi(N)
    cnt = 0    # Counter for coprime pairs
    # Loop through all pairs (a, b) where 1 <= a, b <= N
    for a in 1:N
        for b in 1:N
            # Check if a and b are coprime
            if gcd(a, b) == 1
                cnt += 1  # Increment counter if coprime
            end
        end
    end
    # Probability that two numbers are coprime
    prob = cnt / (N * N)
    # Approximate pi using the formula: pi ≈ sqrt(6 / prob)
    return sqrt(6 / prob)
end

# Main function to run the pi approximation
function main()
    N = 10000            # Number limit for coprimality checking
    approx_pi = @time calcPi(N) # Approximate pi and time it
    println("N: $(N)")   # Output N
    println("pi: $(approx_pi)") # Output approximation of pi
end

main() # Call the main function
```

Result

```sh
julia approx_pi_gcd.jl
  1.454210 seconds
N: 10000
pi: 3.141534239016629
```

---

## Julia が速くなった?!

`1.865392 seconds -> 1.454210 seconds` となる理由は？

Julia が提供する `gcd` 関数はユークリッド互除法とは異なるアルゴリズムを用いているからである．

## Exercise

- Julia のリポジトリをクローンしてコーディングエージェントに `gcd` 関数がどのようになっているかを答えさせよ．

- 採用しているアルゴリズムは何かを答えさせよ．
- 先ほど JavaScript から Rust に移植したコードで `mygcd` の代わりに Julia が実装している `gcd` 関数を移植させよ．

Hint:

`git clone --depth 1 <url>` ですばやくクローンができる(shallow clone)．

> `Read the Julia code and answer how the gcd function is defined. Read @julia`

---

## Answer



---

## Appendix

Goma-chan is cute
